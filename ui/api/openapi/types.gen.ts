// This file is auto-generated by @hey-api/openapi-ts

/**
 * Cause of this alert.
 */
export type AlertCause = 'UNKNOWN_CAUSE' | 'OTHER_CAUSE' | 'TECHNICAL_PROBLEM' | 'STRIKE' | 'DEMONSTRATION' | 'ACCIDENT' | 'HOLIDAY' | 'WEATHER' | 'MAINTENANCE' | 'CONSTRUCTION' | 'POLICE_ACTIVITY' | 'MEDICAL_EMERGENCY';

/**
 * The effect of this problem on the affected entity.
 */
export type AlertEffect = 'NO_SERVICE' | 'REDUCED_SERVICE' | 'SIGNIFICANT_DELAYS' | 'DETOUR' | 'ADDITIONAL_SERVICE' | 'MODIFIED_SERVICE' | 'OTHER_EFFECT' | 'UNKNOWN_EFFECT' | 'STOP_MOVED' | 'NO_EFFECT' | 'ACCESSIBILITY_ISSUE';

/**
 * The severity of the alert.
 */
export type AlertSeverityLevel = 'UNKNOWN_SEVERITY' | 'INFO' | 'WARNING' | 'SEVERE';

/**
 * A time interval.
 * The interval is considered active at time t if t is greater than or equal to the start time and less than the end time.
 *
 */
export type TimeRange = {
    /**
     * If missing, the interval starts at minus infinity.
     * If a TimeRange is provided, either start or end must be provided - both fields cannot be empty.
     *
     */
    start: string;
    /**
     * If missing, the interval ends at plus infinity.
     * If a TimeRange is provided, either start or end must be provided - both fields cannot be empty.
     *
     */
    end: string;
};

/**
 * An alert, indicating some sort of incident in the public transit network.
 */
export type Alert = {
    /**
     * Time when the alert should be shown to the user.
     * If missing, the alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     *
     */
    communicationPeriod?: Array<TimeRange>;
    /**
     * Time when the services are affected by the disruption mentioned in the alert.
     */
    impactPeriod?: Array<TimeRange>;
    cause?: AlertCause;
    /**
     * Description of the cause of the alert that allows for agency-specific language;
     * more specific than the Cause.
     *
     */
    causeDetail?: string;
    effect?: AlertEffect;
    /**
     * Description of the effect of the alert that allows for agency-specific language;
     * more specific than the Effect.
     *
     */
    effectDetail?: string;
    /**
     * The URL which provides additional information about the alert.
     */
    url?: string;
    /**
     * Header for the alert. This plain-text string will be highlighted, for example in boldface.
     *
     */
    headerText: string;
    /**
     * Description for the alert.
     * This plain-text string will be formatted as the body of the alert (or shown on an explicit "expand" request by the user).
     * The information in the description should add to the information of the header.
     *
     */
    descriptionText: string;
    /**
     * Text containing the alert's header to be used for text-to-speech implementations.
     * This field is the text-to-speech version of header_text.
     * It should contain the same information as headerText but formatted such that it can read as text-to-speech
     * (for example, abbreviations removed, numbers spelled out, etc.)
     *
     */
    ttsHeaderText?: string;
    /**
     * Text containing a description for the alert to be used for text-to-speech implementations.
     * This field is the text-to-speech version of description_text.
     * It should contain the same information as description_text but formatted such that it can be read as text-to-speech
     * (for example, abbreviations removed, numbers spelled out, etc.)
     *
     */
    ttsDescriptionText?: string;
    /**
     * Severity of the alert.
     */
    severityLevel?: AlertSeverityLevel;
    /**
     * String containing an URL linking to an image.
     */
    imageUrl?: string;
    /**
     * IANA media type as to specify the type of image to be displayed. The type must start with "image/"
     *
     */
    imageMediaType?: string;
    /**
     * Text describing the appearance of the linked image in the image field
     * (e.g., in case the image can't be displayed or the user can't see the image for accessibility reasons).
     * See the HTML spec for alt image text.
     *
     */
    imageAlternativeText?: string;
};

/**
 * Object containing duration if a path was found or none if no path was found
 */
export type Duration = {
    /**
     * duration in seconds if a path was found, otherwise missing
     */
    duration?: number;
};

/**
 * Administrative area
 */
export type Area = {
    /**
     * Name of the area
     */
    name: string;
    /**
     * [OpenStreetMap `admin_level`](https://wiki.openstreetmap.org/wiki/Key:admin_level)
     * of the area
     *
     */
    adminLevel: number;
    /**
     * Whether this area was matched by the input text
     */
    matched: boolean;
    /**
     * Set for the first area after the `default` area that distinguishes areas
     * if the match is ambiguous regarding (`default` area + place name / street [+ house number]).
     *
     */
    unique?: boolean;
    /**
     * Whether this area should be displayed as default area (area with admin level closest 7)
     */
    default?: boolean;
};

/**
 * Matched token range (from index, length)
 */
export type Token = [
    number,
    number
];

/**
 * location type
 */
export type LocationType = 'ADDRESS' | 'PLACE' | 'STOP';

/**
 * # Street modes
 *
 * - `WALK`
 * - `BIKE`
 * - `RENTAL` Experimental. Expect unannounced breaking changes (without version bumps) for all parameters and returned structs.
 * - `CAR`
 * - `CAR_PARKING` Experimental. Expect unannounced breaking changes (without version bumps) for all parameters and returned structs.
 * - `CAR_DROPOFF` Experimental. Expect unannounced breaking changes (without version bumps) for all perameters and returned structs.
 * - `ODM` on-demand taxis from the Prima+ÖV Project
 * - `RIDE_SHARING` ride sharing from the Prima+ÖV Project
 * - `FLEX` flexible transports
 *
 * # Transit modes
 *
 * - `TRANSIT`: translates to `RAIL,TRAM,BUS,FERRY,AIRPLANE,COACH,CABLE_CAR,FUNICULAR,AREAL_LIFT,OTHER`
 * - `TRAM`: trams
 * - `SUBWAY`: subway trains (Paris Metro, London Underground, but also NYC Subway, Hamburger Hochbahn, and other non-underground services)
 * - `FERRY`: ferries
 * - `AIRPLANE`: airline flights
 * - `BUS`: short distance buses (does not include `COACH`)
 * - `COACH`: long distance buses (does not include `BUS`)
 * - `RAIL`: translates to `HIGHSPEED_RAIL,LONG_DISTANCE,NIGHT_RAIL,REGIONAL_RAIL,REGIONAL_FAST_RAIL,SUBURBAN,SUBWAY`
 * - `SUBURBAN`: suburban trains (e.g. S-Bahn, RER, Elizabeth Line, ...)
 * - `HIGHSPEED_RAIL`: long distance high speed trains (e.g. TGV)
 * - `LONG_DISTANCE`: long distance inter city trains
 * - `NIGHT_RAIL`: long distance night trains
 * - `REGIONAL_FAST_RAIL`: regional express routes that skip low traffic stops to be faster
 * - `REGIONAL_RAIL`: regional train
 * - `FUNICULAR`: Funicular. Any rail system designed for steep inclines.
 * - `AERIAL_LIFT`: Aerial lift, suspended cable car (e.g., gondola lift, aerial tramway). Cable transport where cabins, cars, gondolas or open chairs are suspended by means of one or more cables.
 * - `ODM`: demand responsive transport
 * - `AREAL_LIFT`: deprecated
 * - `METRO`: deprecated
 * - `CABLE_CAR`: deprecated
 *
 */
export type Mode = 'WALK' | 'BIKE' | 'RENTAL' | 'CAR' | 'CAR_PARKING' | 'CAR_DROPOFF' | 'ODM' | 'RIDE_SHARING' | 'FLEX' | 'TRANSIT' | 'TRAM' | 'SUBWAY' | 'FERRY' | 'AIRPLANE' | 'SUBURBAN' | 'BUS' | 'COACH' | 'RAIL' | 'HIGHSPEED_RAIL' | 'LONG_DISTANCE' | 'NIGHT_RAIL' | 'REGIONAL_FAST_RAIL' | 'REGIONAL_RAIL' | 'CABLE_CAR' | 'FUNICULAR' | 'AERIAL_LIFT' | 'OTHER' | 'AREAL_LIFT' | 'METRO';

/**
 * GeoCoding match
 */
export type Match = {
    type: LocationType;
    /**
     * Experimental. Type categories might be adjusted.
     *
     * For OSM stop locations: the amenity type based on
     * https://wiki.openstreetmap.org/wiki/OpenStreetMap_Carto/Symbols
     *
     */
    category?: string;
    /**
     * list of non-overlapping tokens that were matched
     */
    tokens: Array<Token>;
    /**
     * name of the location (transit stop / PoI / address)
     */
    name: string;
    /**
     * unique ID of the location
     */
    id: string;
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    /**
     * level according to OpenStreetMap
     * (at the moment only for public transport)
     *
     */
    level?: number;
    /**
     * street name
     */
    street?: string;
    /**
     * house number
     */
    houseNumber?: string;
    /**
     * ISO3166-1 country code from OpenStreetMap
     */
    country?: string;
    /**
     * zip code
     */
    zip?: string;
    /**
     * timezone name (e.g. "Europe/Berlin")
     */
    tz?: string;
    /**
     * list of areas
     */
    areas: Array<Area>;
    /**
     * score according to the internal scoring system (the scoring algorithm might change in the future)
     */
    score: number;
    /**
     * available transport modes for stops
     */
    modes?: Array<Mode>;
    /**
     * importance of a stop, normalized from [0, 1]
     */
    importance?: number;
};

/**
 * Different elevation cost profiles for street routing.
 * Using a elevation cost profile will prefer routes with a smaller incline and smaller difference in elevation, even if the routed way is longer.
 *
 * - `NONE`: Ignore elevation data for routing. This is the default behavior
 * - `LOW`: Add a low penalty for inclines. This will favor longer paths, if the elevation increase and incline are smaller.
 * - `HIGH`: Add a high penalty for inclines. This will favor even longer paths, if the elevation increase and incline are smaller.
 *
 */
export type ElevationCosts = 'NONE' | 'LOW' | 'HIGH';

/**
 * Different accessibility profiles for pedestrians.
 */
export type PedestrianProfile = 'FOOT' | 'WHEELCHAIR';

/**
 * Average speed for pedestrian routing in meters per second
 */
export type PedestrianSpeed = number;

/**
 * Average speed for bike routing in meters per second
 */
export type CyclingSpeed = number;

/**
 * - `NORMAL` - latitude / longitude coordinate or address
 * - `BIKESHARE` - bike sharing station
 * - `TRANSIT` - transit stop
 *
 */
export type VertexType = 'NORMAL' | 'BIKESHARE' | 'TRANSIT';

/**
 * - `NORMAL` - entry/exit is possible normally
 * - `NOT_ALLOWED` - entry/exit is not allowed
 *
 */
export type PickupDropoffType = 'NORMAL' | 'NOT_ALLOWED';

export type Place = {
    /**
     * name of the transit stop / PoI / address
     */
    name: string;
    /**
     * The ID of the stop. This is often something that users don't care about.
     */
    stopId?: string;
    /**
     * If it's not a root stop, this field contains the `stopId` of the parent stop.
     */
    parentId?: string;
    /**
     * The importance of the stop between 0-1.
     */
    importance?: number;
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    /**
     * level according to OpenStreetMap
     */
    level: number;
    /**
     * timezone name (e.g. "Europe/Berlin")
     */
    tz?: string;
    /**
     * arrival time
     */
    arrival?: string;
    /**
     * departure time
     */
    departure?: string;
    /**
     * scheduled arrival time
     */
    scheduledArrival?: string;
    /**
     * scheduled departure time
     */
    scheduledDeparture?: string;
    /**
     * scheduled track from the static schedule timetable dataset
     */
    scheduledTrack?: string;
    /**
     * The current track/platform information, updated with real-time updates if available.
     * Can be missing if neither real-time updates nor the schedule timetable contains track information.
     *
     */
    track?: string;
    /**
     * description of the location that provides more detailed information
     */
    description?: string;
    vertexType?: VertexType;
    /**
     * Type of pickup. It could be disallowed due to schedule, skipped stops or cancellations.
     */
    pickupType?: PickupDropoffType;
    /**
     * Type of dropoff. It could be disallowed due to schedule, skipped stops or cancellations.
     */
    dropoffType?: PickupDropoffType;
    /**
     * Whether this stop is cancelled due to the realtime situation.
     */
    cancelled?: boolean;
    /**
     * Alerts for this stop.
     */
    alerts?: Array<Alert>;
    /**
     * for `FLEX` transports, the flex location area or location group name
     */
    flex?: string;
    /**
     * for `FLEX` transports, the flex location area ID or location group ID
     */
    flexId?: string;
    /**
     * Time that on-demand service becomes available
     */
    flexStartPickupDropOffWindow?: string;
    /**
     * Time that on-demand service ends
     */
    flexEndPickupDropOffWindow?: string;
};

/**
 * Place reachable by One-to-All
 */
export type ReachablePlace = {
    /**
     * Place reached by One-to-All
     */
    place?: Place;
    /**
     * Total travel duration
     */
    duration?: number;
    /**
     * k is the smallest number, for which a journey with the shortest duration and at most k-1 transfers exist.
     * You can think of k as the number of connections used.
     *
     * In more detail:
     *
     * k=0: No connection, e.g. for the one location
     * k=1: Direct connection
     * k=2: Connection with 1 transfer
     *
     */
    k?: number;
};

/**
 * Object containing all reachable places by One-to-All search
 */
export type Reachable = {
    /**
     * One location used in One-to-All search
     */
    one?: Place;
    /**
     * List of locations reachable by One-to-All
     */
    all?: Array<ReachablePlace>;
};

/**
 * departure or arrival event at a stop
 */
export type StopTime = {
    /**
     * information about the stop place and time
     */
    place: Place;
    /**
     * Transport mode for this leg
     */
    mode: Mode;
    /**
     * Whether there is real-time data about this leg
     */
    realTime: boolean;
    /**
     * The headsign of the bus or train being used.
     * For non-transit legs, null
     *
     */
    headsign: string;
    /**
     * final stop of this trip
     */
    tripTo: Place;
    agencyId: string;
    agencyName: string;
    agencyUrl: string;
    routeId: string;
    directionId: string;
    routeColor?: string;
    routeTextColor?: string;
    tripId: string;
    routeType?: number;
    routeShortName: string;
    routeLongName: string;
    tripShortName: string;
    displayName: string;
    /**
     * Experimental. Expect unannounced breaking changes (without version bumps).
     *
     * Stops on the trips before this stop. Returned only if `fetchStop` and `arriveBy` are `true`.
     *
     */
    previousStops?: Array<Place>;
    /**
     * Experimental. Expect unannounced breaking changes (without version bumps).
     *
     * Stops on the trips after this stop. Returned only if `fetchStop` is `true` and `arriveBy` is `false`.
     *
     */
    nextStops?: Array<Place>;
    /**
     * Type of pickup (for departures) or dropoff (for arrivals), may be disallowed either due to schedule, skipped stops or cancellations
     */
    pickupDropoffType: PickupDropoffType;
    /**
     * Whether the departure/arrival is cancelled due to the realtime situation (either because the stop is skipped or because the entire trip is cancelled).
     */
    cancelled: boolean;
    /**
     * Whether the entire trip is cancelled due to the realtime situation.
     */
    tripCancelled: boolean;
    /**
     * Filename and line number where this trip is from
     */
    source: string;
};

/**
 * trip id and name
 */
export type TripInfo = {
    /**
     * trip ID (dataset trip id prefixed with the dataset tag)
     */
    tripId: string;
    /**
     * trip display name (api version < 4)
     */
    routeShortName?: string;
    /**
     * trip display name (api version >= 4)
     */
    displayName?: string;
};

/**
 * trip segment between two stops to show a trip on a map
 */
export type TripSegment = {
    trips: Array<TripInfo>;
    routeColor?: string;
    /**
     * Transport mode for this leg
     */
    mode: Mode;
    /**
     * distance in meters
     */
    distance: number;
    from: Place;
    to: Place;
    /**
     * departure time
     */
    departure: string;
    /**
     * arrival time
     */
    arrival: string;
    /**
     * scheduled departure time
     */
    scheduledDeparture: string;
    /**
     * scheduled arrival time
     */
    scheduledArrival: string;
    /**
     * Whether there is real-time data about this leg
     */
    realTime: boolean;
    /**
     * Google polyline encoded coordinate sequence (with precision 5) where the trip travels on this segment.
     */
    polyline: string;
};

export type Direction = 'DEPART' | 'HARD_LEFT' | 'LEFT' | 'SLIGHTLY_LEFT' | 'CONTINUE' | 'SLIGHTLY_RIGHT' | 'RIGHT' | 'HARD_RIGHT' | 'CIRCLE_CLOCKWISE' | 'CIRCLE_COUNTERCLOCKWISE' | 'STAIRS' | 'ELEVATOR' | 'UTURN_LEFT' | 'UTURN_RIGHT';

export type EncodedPolyline = {
    /**
     * The encoded points of the polyline using the Google polyline encoding.
     */
    points: string;
    /**
     * The precision of the returned polyline (7 for /v1, 6 for /v2)
     * Be aware that with precision 7, coordinates with |longitude| > 107.37 are undefined/will overflow.
     *
     */
    precision: number;
    /**
     * The number of points in the string
     */
    length: number;
};

export type StepInstruction = {
    relativeDirection: Direction;
    /**
     * The distance in meters that this step takes.
     */
    distance: number;
    /**
     * level where this segment starts, based on OpenStreetMap data
     */
    fromLevel: number;
    /**
     * level where this segment starts, based on OpenStreetMap data
     */
    toLevel: number;
    /**
     * OpenStreetMap way index
     */
    osmWay?: number;
    polyline: EncodedPolyline;
    /**
     * The name of the street.
     */
    streetName: string;
    /**
     * Not implemented!
     * When exiting a highway or traffic circle, the exit name/number.
     *
     */
    exit: string;
    /**
     * Not implemented!
     * Indicates whether or not a street changes direction at an intersection.
     *
     */
    stayOn: boolean;
    /**
     * Not implemented!
     * This step is on an open area, such as a plaza or train platform,
     * and thus the directions should say something like "cross"
     *
     */
    area: boolean;
    /**
     * Indicates that a fee must be paid by general traffic to use a road, road bridge or road tunnel.
     */
    toll?: boolean;
    /**
     * Experimental. Indicates whether access to this part of the route is restricted.
     * See: https://wiki.openstreetmap.org/wiki/Conditional_restrictions
     *
     */
    accessRestriction?: string;
    /**
     * incline in meters across this path segment
     */
    elevationUp?: number;
    /**
     * decline in meters across this path segment
     */
    elevationDown?: number;
};

export type RentalFormFactor = 'BICYCLE' | 'CARGO_BICYCLE' | 'CAR' | 'MOPED' | 'SCOOTER_STANDING' | 'SCOOTER_SEATED' | 'OTHER';

export type RentalPropulsionType = 'HUMAN' | 'ELECTRIC_ASSIST' | 'ELECTRIC' | 'COMBUSTION' | 'COMBUSTION_DIESEL' | 'HYBRID' | 'PLUG_IN_HYBRID' | 'HYDROGEN_FUEL_CELL';

export type RentalReturnConstraint = 'NONE' | 'ANY_STATION' | 'ROUNDTRIP_STATION';

/**
 * Vehicle rental
 */
export type Rental = {
    /**
     * Rental provider ID
     */
    providerId: string;
    /**
     * Rental provider group ID
     */
    providerGroupId: string;
    /**
     * Vehicle share system ID
     */
    systemId: string;
    /**
     * Vehicle share system name
     */
    systemName?: string;
    /**
     * URL of the vehicle share system
     */
    url?: string;
    /**
     * Color associated with this provider, in hexadecimal RGB format
     * (e.g. "#FF0000" for red). Can be empty.
     *
     */
    color?: string;
    /**
     * Name of the station
     */
    stationName?: string;
    /**
     * Name of the station where the vehicle is picked up (empty for free floating vehicles)
     */
    fromStationName?: string;
    /**
     * Name of the station where the vehicle is returned (empty for free floating vehicles)
     */
    toStationName?: string;
    /**
     * Rental URI for Android (deep link to the specific station or vehicle)
     */
    rentalUriAndroid?: string;
    /**
     * Rental URI for iOS (deep link to the specific station or vehicle)
     */
    rentalUriIOS?: string;
    /**
     * Rental URI for web (deep link to the specific station or vehicle)
     */
    rentalUriWeb?: string;
    formFactor?: RentalFormFactor;
    propulsionType?: RentalPropulsionType;
    returnConstraint?: RentalReturnConstraint;
};

/**
 * A multi-polygon contains a number of polygons, each containing a number
 * of rings, which are encoded as polylines (with precision 6).
 *
 * For each polygon, the first ring is the outer ring, all subsequent rings
 * are inner rings (holes).
 *
 */
export type MultiPolygon = Array<Array<EncodedPolyline>>;

export type RentalZoneRestrictions = {
    /**
     * List of vehicle types (as indices into the provider's vehicle types
     * array) to which these restrictions apply.
     * If empty, the restrictions apply to all vehicle types of the provider.
     *
     */
    vehicleTypeIdxs: Array<(number)>;
    /**
     * whether the ride is allowed to start in this zone
     */
    rideStartAllowed: boolean;
    /**
     * whether the ride is allowed to end in this zone
     */
    rideEndAllowed: boolean;
    /**
     * whether the ride is allowed to pass through this zone
     */
    rideThroughAllowed: boolean;
    /**
     * whether vehicles can only be parked at stations in this zone
     */
    stationParking?: boolean;
};

export type RentalVehicleType = {
    /**
     * Unique identifier of the vehicle type (unique within the provider)
     */
    id: string;
    /**
     * Public name of the vehicle type (can be empty)
     */
    name?: string;
    formFactor: RentalFormFactor;
    propulsionType: RentalPropulsionType;
    returnConstraint: RentalReturnConstraint;
    /**
     * Whether the return constraint was guessed instead of being specified by the rental provider
     */
    returnConstraintGuessed: boolean;
};

export type RentalProvider = {
    /**
     * Unique identifier of the rental provider
     */
    id: string;
    /**
     * Name of the provider to be displayed to customers
     */
    name: string;
    /**
     * Id of the rental provider group this provider belongs to
     */
    groupId: string;
    /**
     * Name of the system operator
     */
    operator?: string;
    /**
     * URL of the vehicle share system
     */
    url?: string;
    /**
     * URL where a customer can purchase a membership
     */
    purchaseUrl?: string;
    /**
     * Color associated with this provider, in hexadecimal RGB format
     * (e.g. "#FF0000" for red). Can be empty.
     *
     */
    color?: string;
    /**
     * Bounding box of the area covered by this rental provider,
     * [west, south, east, north] as [lon, lat, lon, lat]
     *
     */
    bbox: [
        number,
        number,
        number,
        number
    ];
    vehicleTypes: Array<RentalVehicleType>;
    /**
     * List of form factors offered by this provider
     */
    formFactors: Array<RentalFormFactor>;
    defaultRestrictions: RentalZoneRestrictions;
    globalGeofencingRules: Array<RentalZoneRestrictions>;
};

export type RentalProviderGroup = {
    /**
     * Unique identifier of the rental provider group
     */
    id: string;
    /**
     * Name of the provider group to be displayed to customers
     */
    name: string;
    /**
     * Color associated with this provider group, in hexadecimal RGB format
     * (e.g. "#FF0000" for red). Can be empty.
     *
     */
    color?: string;
    /**
     * List of rental provider IDs that belong to this group
     */
    providers: Array<(string)>;
    /**
     * List of form factors offered by this provider group
     */
    formFactors: Array<RentalFormFactor>;
};

export type RentalStation = {
    /**
     * Unique identifier of the rental station
     */
    id: string;
    /**
     * Unique identifier of the rental provider
     */
    providerId: string;
    /**
     * Unique identifier of the rental provider group
     */
    providerGroupId: string;
    /**
     * Public name of the station
     */
    name: string;
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    /**
     * Address where the station is located
     */
    address?: string;
    /**
     * Cross street or landmark where the station is located
     */
    crossStreet?: string;
    /**
     * Rental URI for Android (deep link to the specific station)
     */
    rentalUriAndroid?: string;
    /**
     * Rental URI for iOS (deep link to the specific station)
     */
    rentalUriIOS?: string;
    /**
     * Rental URI for web (deep link to the specific station)
     */
    rentalUriWeb?: string;
    /**
     * true if vehicles can be rented from this station, false if it is temporarily out of service
     */
    isRenting: boolean;
    /**
     * true if vehicles can be returned to this station, false if it is temporarily out of service
     */
    isReturning: boolean;
    /**
     * Number of vehicles available for rental at this station
     */
    numVehiclesAvailable: number;
    /**
     * List of form factors available for rental and/or return at this station
     */
    formFactors: Array<RentalFormFactor>;
    /**
     * List of vehicle types currently available at this station (vehicle type ID -> count)
     */
    vehicleTypesAvailable: {
        [key: string]: (number);
    };
    /**
     * List of vehicle docks currently available at this station (vehicle type ID -> count)
     */
    vehicleDocksAvailable: {
        [key: string]: (number);
    };
    stationArea?: MultiPolygon;
    /**
     * Bounding box of the area covered by this station,
     * [west, south, east, north] as [lon, lat, lon, lat]
     *
     */
    bbox: [
        number,
        number,
        number,
        number
    ];
};

export type RentalVehicle = {
    /**
     * Unique identifier of the rental vehicle
     */
    id: string;
    /**
     * Unique identifier of the rental provider
     */
    providerId: string;
    /**
     * Unique identifier of the rental provider group
     */
    providerGroupId: string;
    /**
     * Vehicle type ID (unique within the provider)
     */
    typeId: string;
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    formFactor: RentalFormFactor;
    propulsionType: RentalPropulsionType;
    returnConstraint: RentalReturnConstraint;
    /**
     * Station ID if the vehicle is currently at a station
     */
    stationId?: string;
    /**
     * Station ID where the vehicle must be returned, if applicable
     */
    homeStationId?: string;
    /**
     * true if the vehicle is currently reserved by a customer, false otherwise
     */
    isReserved: boolean;
    /**
     * true if the vehicle is out of service, false otherwise
     */
    isDisabled: boolean;
    /**
     * Rental URI for Android (deep link to the specific vehicle)
     */
    rentalUriAndroid?: string;
    /**
     * Rental URI for iOS (deep link to the specific vehicle)
     */
    rentalUriIOS?: string;
    /**
     * Rental URI for web (deep link to the specific vehicle)
     */
    rentalUriWeb?: string;
};

export type RentalZone = {
    /**
     * Unique identifier of the rental provider
     */
    providerId: string;
    /**
     * Unique identifier of the rental provider group
     */
    providerGroupId: string;
    /**
     * Public name of the geofencing zone
     */
    name?: string;
    /**
     * Zone precedence / z-index (higher number = higher precedence)
     */
    z: number;
    /**
     * Bounding box of the area covered by this zone,
     * [west, south, east, north] as [lon, lat, lon, lat]
     *
     */
    bbox: [
        number,
        number,
        number,
        number
    ];
    area: MultiPolygon;
    rules: Array<RentalZoneRestrictions>;
};

export type Leg = {
    /**
     * Transport mode for this leg
     */
    mode: Mode;
    from: Place;
    to: Place;
    /**
     * Leg duration in seconds
     *
     * If leg is footpath:
     * The footpath duration is derived from the default footpath
     * duration using the query parameters `transferTimeFactor` and
     * `additionalTransferTime` as follows:
     * `leg.duration = defaultDuration * transferTimeFactor + additionalTransferTime.`
     * In case the defaultDuration is needed, it can be calculated by
     * `defaultDuration = (leg.duration - additionalTransferTime) / transferTimeFactor`.
     * Note that the default values are `transferTimeFactor = 1` and
     * `additionalTransferTime = 0` in case they are not explicitly
     * provided in the query.
     *
     */
    duration: number;
    /**
     * leg departure time
     */
    startTime: string;
    /**
     * leg arrival time
     */
    endTime: string;
    /**
     * scheduled leg departure time
     */
    scheduledStartTime: string;
    /**
     * scheduled leg arrival time
     */
    scheduledEndTime: string;
    /**
     * Whether there is real-time data about this leg
     */
    realTime: boolean;
    /**
     * Whether this leg was originally scheduled to run or is an additional service.
     * Scheduled times will equal realtime times in this case.
     *
     */
    scheduled: boolean;
    /**
     * For non-transit legs the distance traveled while traversing this leg in meters.
     */
    distance?: number;
    /**
     * For transit legs, if the rider should stay on the vehicle as it changes route names.
     */
    interlineWithPreviousLeg?: boolean;
    /**
     * For transit legs, the headsign of the bus or train being used.
     * For non-transit legs, null
     *
     */
    headsign?: string;
    /**
     * final stop of this trip (can differ from headsign)
     */
    tripTo?: Place;
    routeId?: string;
    directionId?: string;
    routeColor?: string;
    routeTextColor?: string;
    routeType?: number;
    agencyName?: string;
    agencyUrl?: string;
    agencyId?: string;
    tripId?: string;
    routeShortName?: string;
    routeLongName?: string;
    tripShortName?: string;
    displayName?: string;
    /**
     * Whether this trip is cancelled
     */
    cancelled?: boolean;
    /**
     * Filename and line number where this trip is from
     */
    source?: string;
    /**
     * For transit legs, intermediate stops between the Place where the leg originates
     * and the Place where the leg ends. For non-transit legs, null.
     *
     */
    intermediateStops?: Array<Place>;
    legGeometry: EncodedPolyline;
    /**
     * A series of turn by turn instructions
     * used for walking, biking and driving.
     *
     */
    steps?: Array<StepInstruction>;
    rental?: Rental;
    /**
     * Index into `Itinerary.fareTransfers` array
     * to identify which fare transfer this leg belongs to
     *
     */
    fareTransferIndex?: number;
    /**
     * Index into the `Itinerary.fareTransfers[fareTransferIndex].effectiveFareLegProducts` array
     * to identify which effective fare leg this itinerary leg belongs to
     *
     */
    effectiveFareLegIndex?: number;
    /**
     * Alerts for this stop.
     */
    alerts?: Array<Alert>;
    /**
     * If set, this attribute indicates that this trip has been expanded
     * beyond the feed end date (enabled by config flag `timetable.dataset.extend_calendar`)
     * by looping active weekdays, e.g. from calendar.txt in GTFS.
     *
     */
    loopedCalendarSince?: string;
};

export type RiderCategory = {
    /**
     * Rider category name as displayed to the rider.
     */
    riderCategoryName: string;
    /**
     * Specifies if this category should be considered the default (i.e. the main category displayed to riders).
     */
    isDefaultFareCategory: boolean;
    /**
     * URL to a web page providing detailed information about the rider category and/or its eligibility criteria.
     */
    eligibilityUrl?: string;
};

/**
 * - `NONE`: No fare media involved (e.g., cash payment)
 * - `PAPER_TICKET`: Physical paper ticket
 * - `TRANSIT_CARD`: Physical transit card with stored value
 * - `CONTACTLESS_EMV`: cEMV (contactless payment)
 * - `MOBILE_APP`: Mobile app with virtual transit cards/passes
 *
 */
export type FareMediaType = 'NONE' | 'PAPER_TICKET' | 'TRANSIT_CARD' | 'CONTACTLESS_EMV' | 'MOBILE_APP';

export type FareMedia = {
    /**
     * Name of the fare media. Required for transit cards and mobile apps.
     */
    fareMediaName?: string;
    /**
     * The type of fare media.
     */
    fareMediaType: FareMediaType;
};

export type FareProduct = {
    /**
     * The name of the fare product as displayed to riders.
     */
    name: string;
    /**
     * The cost of the fare product. May be negative to represent transfer discounts. May be zero to represent a fare product that is free.
     */
    amount: number;
    /**
     * ISO 4217 currency code. The currency of the cost of the fare product.
     */
    currency: string;
    riderCategory?: RiderCategory;
    media?: FareMedia;
};

export type FareTransferRule = 'A_AB' | 'A_AB_B' | 'AB';

/**
 * The concept is derived from: https://gtfs.org/documentation/schedule/reference/#fare_transfer_rulestxt
 *
 * Terminology:
 * - **Leg**: An itinerary leg as described by the `Leg` type of this API description.
 * - **Effective Fare Leg**: Itinerary legs can be joined together to form one *effective fare leg*.
 * - **Fare Transfer**: A fare transfer groups two or more effective fare legs.
 * - **A** is the first *effective fare leg* of potentially multiple consecutive legs contained in a fare transfer
 * - **B** is any *effective fare leg* following the first *effective fare leg* in this transfer
 * - **AB** are all changes between *effective fare legs* contained in this transfer
 *
 * The fare transfer rule is used to derive the final set of products of the itinerary legs contained in this transfer:
 * - A_AB means that any product from the first effective fare leg combined with the product attached to the transfer itself (AB) which can be empty (= free). Note that all subsequent effective fare leg products need to be ignored in this case.
 * - A_AB_B mean that a product for each effective fare leg needs to be purchased in a addition to the product attached to the transfer itself (AB) which can be empty (= free)
 * - AB only the transfer product itself has to be purchased. Note that all fare products attached to the contained effective fare legs need to be ignored in this case.
 *
 * An itinerary `Leg` references the index of the fare transfer and the index of the effective fare leg in this transfer it belongs to.
 *
 */
export type FareTransfer = {
    rule?: FareTransferRule;
    transferProducts?: Array<FareProduct>;
    /**
     * Lists all valid fare products for the effective fare legs.
     * This is an `array<array<FareProduct>>` where the inner array
     * lists all possible fare products that would cover this effective fare leg.
     * Each "effective fare leg" can have multiple options for adult/child/weekly/monthly/day/one-way tickets etc.
     * You can see the outer array as AND (you need one ticket for each effective fare leg (`A_AB_B`), the first effective fare leg (`A_AB`) or no fare leg at all but only the transfer product (`AB`)
     * and the inner array as OR (you can choose which ticket to buy)
     *
     */
    effectiveFareLegProducts: Array<Array<Array<FareProduct>>>;
};

export type Itinerary = {
    /**
     * journey duration in seconds
     */
    duration: number;
    /**
     * journey departure time
     */
    startTime: string;
    /**
     * journey arrival time
     */
    endTime: string;
    /**
     * The number of transfers this trip has.
     */
    transfers: number;
    /**
     * Journey legs
     */
    legs: Array<Leg>;
    /**
     * Fare information
     */
    fareTransfers?: Array<FareTransfer>;
};

/**
 * transfer from one location to another
 */
export type Transfer = {
    to: Place;
    /**
     * optional; missing if the GTFS did not contain a transfer
     * transfer duration in minutes according to GTFS (+heuristics)
     *
     */
    default?: number;
    /**
     * optional; missing if no path was found (timetable / osr)
     * transfer duration in minutes for the foot profile
     *
     */
    foot?: number;
    /**
     * optional; missing if no path was found with foot routing
     * transfer duration in minutes for the foot profile
     *
     */
    footRouted?: number;
    /**
     * optional; missing if no path was found with the wheelchair profile
     * transfer duration in minutes for the wheelchair profile
     *
     */
    wheelchair?: number;
    /**
     * optional; missing if no path was found with the wheelchair profile
     * transfer duration in minutes for the wheelchair profile
     *
     */
    wheelchairRouted?: number;
    /**
     * optional; missing if no path was found with the wheelchair profile
     * true if the wheelchair path uses an elevator
     *
     */
    wheelchairUsesElevator?: boolean;
    /**
     * optional; missing if no path was found with car routing
     * transfer duration in minutes for the car profile
     *
     */
    car?: number;
};

export type OneToManyParams = {
    /**
     * geo location as latitude;longitude
     */
    one: string;
    /**
     * geo locations as latitude;longitude,latitude;longitude,...
     */
    many: Array<(string)>;
    /**
     * routing profile to use (currently supported: \`WALK\`, \`BIKE\`, \`CAR\`)
     *
     */
    mode: Mode;
    /**
     * maximum travel time in seconds
     */
    max: number;
    /**
     * maximum matching distance in meters to match geo coordinates to the street network
     */
    maxMatchingDistance: number;
    /**
     * Optional. Default is `NONE`.
     *
     * Set an elevation cost profile, to penalize routes with incline.
     * - `NONE`: No additional costs for elevations. This is the default behavior
     * - `LOW`: Add a low cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if small detours are required.
     * - `HIGH`: Add a high cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if larger detours are required.
     *
     * As using an elevation costs profile will increase the travel duration,
     * routing through steep terrain may exceed the maximal allowed duration,
     * causing a location to appear unreachable.
     * Increasing the maximum travel time for these segments may resolve this issue.
     *
     * Elevation cost profiles are currently used by following street modes:
     * - `BIKE`
     *
     */
    elevationCosts: ElevationCosts;
    /**
     * true = many to one
     * false = one to many
     *
     */
    arriveBy: boolean;
};

export type ServerConfig = {
    /**
     * true if elevation is loaded
     */
    hasElevation: boolean;
    /**
     * true if routed transfers available
     */
    hasRoutedTransfers: boolean;
    /**
     * true if street routing is available
     */
    hasStreetRouting: boolean;
    /**
     * limit for maxTravelTime API param in minutes
     */
    maxOneToAllTravelTimeLimit?: number;
    /**
     * limit for maxPrePostTransitTime API param in seconds
     */
    maxPrePostTransitTimeLimit: number;
    /**
     * limit for maxDirectTime API param in seconds
     */
    maxDirectTimeLimit: number;
};

export type Error = {
    error?: string;
};

export type PlanData = {
    query: {
        /**
         * Optional. Default is 0 minutes.
         *
         * Additional transfer time reserved for each transfer in minutes.
         *
         */
        additionalTransferTime?: number;
        /**
         * algorithm to use
         */
        algorithm?: 'RAPTOR' | 'PONG' | 'TB';
        /**
         * Optional. Default is `false`.
         *
         * - `arriveBy=true`: the parameters `date` and `time` refer to the arrival time
         * - `arriveBy=false`: the parameters `date` and `time` refer to the departure time
         *
         */
        arriveBy?: boolean;
        /**
         * Optional
         *
         * Average speed for bike routing.
         *
         */
        cyclingSpeed?: CyclingSpeed;
        /**
         * - true: Compute transfer polylines and step instructions.
         * - false: Only return basic information (start time, end time, duration) for transfers.
         *
         */
        detailedTransfers: boolean;
        /**
         * Optional. Default is `WALK` which will compute walking routes as direct connections.
         *
         * Modes used for direction connections from start to destination without using transit.
         * Results will be returned on the `direct` key.
         *
         * Note: Direct connections will only be returned on the first call. For paging calls, they can be omitted.
         *
         * Note: Transit connections that are slower than the fastest direct connection will not show up.
         * This is being used as a cut-off during transit routing to speed up the search.
         * To prevent this, it's possible to send two separate requests (one with only `transitModes` and one with only `directModes`).
         *
         * Note: the output `direct` array will stay empty if the input param `maxDirectTime` makes any direct trip impossible.
         *
         * Only non-transit modes such as `WALK`, `BIKE`, `CAR`, `BIKE_SHARING`, etc. can be used.
         *
         */
        directModes?: Array<Mode>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies to direct connections.
         *
         * A list of vehicle type form factors that are allowed to be used for direct connections.
         * If empty (the default), all form factors are allowed.
         * Example: `BICYCLE,SCOOTER_STANDING`.
         *
         */
        directRentalFormFactors?: Array<RentalFormFactor>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies to direct connections.
         *
         * A list of vehicle type form factors that are allowed to be used for direct connections.
         * If empty (the default), all propulsion types are allowed.
         * Example: `HUMAN,ELECTRIC,ELECTRIC_ASSIST`.
         *
         */
        directRentalPropulsionTypes?: Array<RentalPropulsionType>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies to direct connections.
         *
         * A list of rental provider groups that are allowed to be used for direct connections.
         * If empty (the default), all providers are allowed.
         *
         */
        directRentalProviderGroups?: Array<(string)>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies to direct connections.
         *
         * A list of rental providers that are allowed to be used for direct connections.
         * If empty (the default), all providers are allowed.
         *
         */
        directRentalProviders?: Array<(string)>;
        /**
         * Optional. Default is `NONE`.
         *
         * Set an elevation cost profile, to penalize routes with incline.
         * - `NONE`: No additional costs for elevations. This is the default behavior
         * - `LOW`: Add a low cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if small detours are required.
         * - `HIGH`: Add a high cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if larger detours are required.
         *
         * As using an elevation costs profile will increase the travel duration,
         * routing through steep terrain may exceed the maximal allowed duration,
         * causing a location to appear unreachable.
         * Increasing the maximum travel time for these segments may resolve this issue.
         *
         * The profile is used for direct routing, on the first mile, and last mile.
         *
         * Elevation cost profiles are currently used by following street modes:
         * - `BIKE`
         *
         */
        elevationCosts?: ElevationCosts;
        /**
         * Optional. Experimental. Default is `1.0`.
         * Factor with which the duration of the fastest direct non-public-transit connection is multiplied.
         * Values > 1.0 allow transit connections that are slower than the fastest direct non-public-transit connection to be found.
         *
         */
        fastestDirectFactor?: number;
        /**
         * Optional.
         * Factor with which the duration of the fastest slowDirect connection is multiplied.
         * Values > 1.0 allow connections that are slower than the fastest direct transit connection to be found.
         * Values < 1.0 will return all slowDirect connections.
         *
         */
        fastestSlowDirectFactor?: number;
        /**
         * \`latitude,longitude[,level]\` tuple with
         * - latitude and longitude in degrees
         * - (optional) level: the OSM level (default: 0)
         *
         * OR
         *
         * stop id
         *
         */
        fromPlace: string;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Default is `false`.
         *
         * If set to `true`, the routing will ignore rental return constraints for direct connections,
         * allowing the rental vehicle to be parked anywhere.
         *
         */
        ignoreDirectRentalReturnConstraints?: boolean;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Default is `false`.
         *
         * If set to `true`, the routing will ignore rental return constraints for the part from the last transit stop to the `to` coordinate,
         * allowing the rental vehicle to be parked anywhere.
         *
         */
        ignorePostTransitRentalReturnConstraints?: boolean;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Default is `false`.
         *
         * If set to `true`, the routing will ignore rental return constraints for the part from the `from` coordinate to the first transit stop,
         * allowing the rental vehicle to be parked anywhere.
         *
         */
        ignorePreTransitRentalReturnConstraints?: boolean;
        /**
         * Optional. Default is `true`.
         *
         * Controls if a journey section with stay-seated transfers is returned:
         * - `joinInterlinedLegs=false`: as several legs (full information about all trip numbers, headsigns, etc.).
         * Legs that do not require a transfer (stay-seated transfer) are marked with `interlineWithPreviousLeg=true`.
         * - `joinInterlinedLegs=true` (default behavior): as only one joined leg containing all stops
         *
         */
        joinInterlinedLegs?: boolean;
        /**
         * language tags as used in OpenStreetMap / GTFS
         * (usually BCP-47 / ISO 639-1, or ISO 639-2 if there's no ISO 639-1)
         *
         */
        language?: Array<(string)>;
        /**
         * Optional. Experimental. Number of luggage pieces; base unit: airline cabin luggage (e.g. for ODM or price calculation)
         *
         */
        luggage?: number;
        /**
         * Optional. Default is 30min which is `1800`.
         * Maximum time in seconds for direct connections.
         * Is limited by server config variable `street_routing_max_direct_seconds`.
         *
         */
        maxDirectTime?: number;
        /**
         * Optional. By default all computed itineraries will be returned
         *
         * The maximum number of itineraries to compute.
         * This is only relevant if `timetableView=true`.
         *
         * Note: With the current implementation, setting this to a lower
         * number will not result in any speedup.
         *
         * Note: The number of returned itineraries might be slightly higher
         * than `maxItineraries` as there might be several itineraries with
         * the same departure time but different number of transfers. In order
         * to not miss any itineraries for paging, either none or all
         * itineraries with the same departure time have to be returned.
         *
         */
        maxItineraries?: number;
        /**
         * Optional. Default is 25 meters.
         *
         * Maximum matching distance in meters to match geo coordinates to the street network.
         *
         */
        maxMatchingDistance?: number;
        /**
         * Optional. Default is 15min which is `900`.
         * Maximum time in seconds for the last street leg.
         * Is limited by server config variable `street_routing_max_prepost_transit_seconds`.
         *
         */
        maxPostTransitTime?: number;
        /**
         * Optional. Default is 15min which is `900`.
         * Maximum time in seconds for the first street leg.
         * Is limited by server config variable `street_routing_max_prepost_transit_seconds`.
         *
         */
        maxPreTransitTime?: number;
        /**
         * The maximum number of allowed transfers (i.e. interchanges between transit legs,
         * pre- and postTransit do not count as transfers).
         * `maxTransfers=0` searches for direct transit connections without any transfers.
         * If you want to search only for non-transit connections (`FOOT`, `CAR`, etc.),
         * send an empty `transitModes` parameter instead.
         *
         * If not provided, the routing uses the server-side default value
         * which is hardcoded and very high to cover all use cases.
         *
         * *Warning*: Use with care. Setting this too low can lead to
         * optimal (e.g. the fastest) journeys not being found.
         * If this value is too low to reach the destination at all,
         * it can lead to slow routing performance.
         *
         * In plan endpoints before v3, the behavior is off by one,
         * i.e. `maxTransfers=0` only returns non-transit connections.
         *
         */
        maxTransfers?: number;
        /**
         * The maximum travel time in minutes.
         * If not provided, the routing to uses the value
         * hardcoded in the server which is usually quite high.
         *
         * *Warning*: Use with care. Setting this too low can lead to
         * optimal (e.g. the least transfers) journeys not being found.
         * If this value is too low to reach the destination at all,
         * it can lead to slow routing performance.
         *
         */
        maxTravelTime?: number;
        /**
         * Optional. Default is 0 minutes.
         *
         * Minimum transfer time for each transfer in minutes.
         *
         */
        minTransferTime?: number;
        /**
         * The minimum number of itineraries to compute.
         * This is only relevant if `timetableView=true`.
         * The default value is 5.
         *
         */
        numItineraries?: number;
        /**
         * Use the cursor to go to the next "page" of itineraries.
         * Copy the cursor from the last response and keep the original request as is.
         * This will enable you to search for itineraries in the next or previous time-window.
         *
         */
        pageCursor?: string;
        /**
         * Optional. Experimental. Number of passengers (e.g. for ODM or price calculation)
         */
        passengers?: number;
        /**
         * Optional. Default is `FOOT`.
         *
         * Accessibility profile to use for pedestrian routing in transfers
         * between transit connections, on the first mile, and last mile.
         *
         */
        pedestrianProfile?: PedestrianProfile;
        /**
         * Optional
         *
         * Average speed for pedestrian routing.
         *
         */
        pedestrianSpeed?: PedestrianSpeed;
        /**
         * Optional. Default is `WALK`. Only applies if the `to` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directModes`).
         *
         * A list of modes that are allowed to be used from the last transit stop to the `to` coordinate. Example: `WALK,BIKE_SHARING`.
         *
         */
        postTransitModes?: Array<Mode>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `to` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalFormFactors`).
         *
         * A list of vehicle type form factors that are allowed to be used from the last transit stop to the `to` coordinate.
         * If empty (the default), all form factors are allowed.
         * Example: `BICYCLE,SCOOTER_STANDING`.
         *
         */
        postTransitRentalFormFactors?: Array<RentalFormFactor>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `to` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalPropulsionTypes`).
         *
         * A list of vehicle propulsion types that are allowed to be used from the last transit stop to the `to` coordinate.
         * If empty (the default), all propulsion types are allowed.
         * Example: `HUMAN,ELECTRIC,ELECTRIC_ASSIST`.
         *
         */
        postTransitRentalPropulsionTypes?: Array<RentalPropulsionType>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `to` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalProviderGroups`).
         *
         * A list of rental provider groups that are allowed to be used from the last transit stop to the `to` coordinate.
         * If empty (the default), all providers are allowed.
         *
         */
        postTransitRentalProviderGroups?: Array<(string)>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `to` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalProviders`).
         *
         * A list of rental providers that are allowed to be used from the last transit stop to the `to` coordinate.
         * If empty (the default), all providers are allowed.
         *
         */
        postTransitRentalProviders?: Array<(string)>;
        /**
         * Optional. Default is `WALK`. Only applies if the `from` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directModes`).
         *
         * A list of modes that are allowed to be used from the `from` coordinate to the first transit stop. Example: `WALK,BIKE_SHARING`.
         *
         */
        preTransitModes?: Array<Mode>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `from` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalFormFactors`).
         *
         * A list of vehicle type form factors that are allowed to be used from the `from` coordinate to the first transit stop.
         * If empty (the default), all form factors are allowed.
         * Example: `BICYCLE,SCOOTER_STANDING`.
         *
         */
        preTransitRentalFormFactors?: Array<RentalFormFactor>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `from` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalPropulsionTypes`).
         *
         * A list of vehicle propulsion types that are allowed to be used from the `from` coordinate to the first transit stop.
         * If empty (the default), all propulsion types are allowed.
         * Example: `HUMAN,ELECTRIC,ELECTRIC_ASSIST`.
         *
         */
        preTransitRentalPropulsionTypes?: Array<RentalPropulsionType>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `from` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalProviderGroups`).
         *
         * A list of rental provider groups that are allowed to be used from the `from` coordinate to the first transit stop.
         * If empty (the default), all providers are allowed.
         *
         */
        preTransitRentalProviderGroups?: Array<(string)>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `from` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalProviders`).
         *
         * A list of rental providers that are allowed to be used from the `from` coordinate to the first transit stop.
         * If empty (the default), all providers are allowed.
         *
         */
        preTransitRentalProviders?: Array<(string)>;
        /**
         * Optional. Default is `false`.
         *
         * If set to `true`, all used transit trips are required to allow bike carriage.
         *
         */
        requireBikeTransport?: boolean;
        /**
         * Optional. Default is `false`.
         *
         * If set to `true`, all used transit trips are required to allow car carriage.
         *
         */
        requireCarTransport?: boolean;
        /**
         * Optional. Default is 15 minutes which is `900`.
         *
         * The length of the search-window in seconds. Default value 15 minutes.
         *
         * - `arriveBy=true`: number of seconds between the earliest departure time and latest departure time
         * - `arriveBy=false`: number of seconds between the earliest arrival time and the latest arrival time
         *
         */
        searchWindow?: number;
        /**
         * Optional. Experimental. Adds overtaken direct public transit connections.
         */
        slowDirect?: boolean;
        /**
         * Optional. Defaults to the current time.
         *
         * Departure time ($arriveBy=false) / arrival date ($arriveBy=true),
         *
         */
        time?: string;
        /**
         * Optional. Query timeout in seconds.
         */
        timeout?: number;
        /**
         * Optional. Default is `true`.
         *
         * Search for the best trip options within a time window.
         * If true two itineraries are considered optimal
         * if one is better on arrival time (earliest wins)
         * and the other is better on departure time (latest wins).
         * In combination with arriveBy this parameter cover the following use cases:
         *
         * `timetable=false` = waiting for the first transit departure/arrival is considered travel time:
         * - `arriveBy=true`: event (e.g. a meeting) starts at 10:00 am,
         * compute the best journeys that arrive by that time (maximizes departure time)
         * - `arriveBy=false`: event (e.g. a meeting) ends at 11:00 am,
         * compute the best journeys that depart after that time
         *
         * `timetable=true` = optimize "later departure" + "earlier arrival" and give all options over a time window:
         * - `arriveBy=true`: the time window around `date` and `time` refers to the arrival time window
         * - `arriveBy=false`: the time window around `date` and `time` refers to the departure time window
         *
         */
        timetableView?: boolean;
        /**
         * \`latitude,longitude[,level]\` tuple with
         * - latitude and longitude in degrees
         * - (optional) level: the OSM level (default: 0)
         *
         * OR
         *
         * stop id
         *
         */
        toPlace: string;
        /**
         * Optional. Default is 1.0
         *
         * Factor to multiply minimum required transfer times with.
         * Values smaller than 1.0 are not supported.
         *
         */
        transferTimeFactor?: number;
        /**
         * Optional. Default is `TRANSIT` which allows all transit modes (no restriction).
         * Allowed modes for the transit part. If empty, no transit connections will be computed.
         * For example, this can be used to allow only `SUBURBAN,SUBWAY,TRAM`.
         *
         */
        transitModes?: Array<Mode>;
        /**
         * Optional. Default is `false`.
         *
         * Whether to use transfers routed on OpenStreetMap data.
         *
         */
        useRoutedTransfers?: boolean;
        /**
         * List of via stops to visit (only stop IDs, no coordinates allowed for now).
         * Also see the optional parameter `viaMinimumStay` to set a set a minimum stay duration for each via stop.
         *
         */
        via?: Array<(string)>;
        /**
         * Optional. If not set, the default is `0,0` - no stay required.
         *
         * For each `via` stop a minimum stay duration in minutes.
         *
         * The value `0` signals that it's allowed to stay in the same trip.
         * This enables via stays without counting a transfer and can lead
         * to better connections with less transfers. Transfer connections can
         * still be found with `viaMinimumStay=0`.
         *
         */
        viaMinimumStay?: Array<(number)>;
        /**
         * Optional. Experimental. If set to true, the response will contain fare information.
         */
        withFares?: boolean;
        /**
         * Optional. Include intermediate stops where passengers can not alight/board according to schedule.
         */
        withScheduledSkippedStops?: boolean;
    };
};

export type PlanResponse = ({
    /**
     * the routing query
     */
    requestParameters: {
        [key: string]: (string);
    };
    /**
     * debug statistics
     */
    debugOutput: {
        [key: string]: (number);
    };
    from: Place;
    to: Place;
    /**
     * Direct trips by `WALK`, `BIKE`, `CAR`, etc. without time-dependency.
     * The starting time (`arriveBy=false`) / arrival time (`arriveBy=true`) is always the queried `time` parameter (set to \"now\" if not set).
     * But all `direct` connections are meant to be independent of absolute times.
     *
     */
    direct: Array<Itinerary>;
    /**
     * list of itineraries
     */
    itineraries: Array<Itinerary>;
    /**
     * Use the cursor to get the previous page of results. Insert the cursor into the request and post it to get the previous page.
     * The previous page is a set of itineraries departing BEFORE the first itinerary in the result for a depart after search. When using the default sort order the previous set of itineraries is inserted before the current result.
     *
     */
    previousPageCursor: string;
    /**
     * Use the cursor to get the next page of results. Insert the cursor into the request and post it to get the next page.
     * The next page is a set of itineraries departing AFTER the last itinerary in this result.
     *
     */
    nextPageCursor: string;
});

export type PlanError = (Error);

export type OneToManyData = {
    query: {
        /**
         * true = many to one
         * false = one to many
         *
         */
        arriveBy: boolean;
        /**
         * Optional. Default is `NONE`.
         *
         * Set an elevation cost profile, to penalize routes with incline.
         * - `NONE`: No additional costs for elevations. This is the default behavior
         * - `LOW`: Add a low cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if small detours are required.
         * - `HIGH`: Add a high cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if larger detours are required.
         *
         * As using an elevation costs profile will increase the travel duration,
         * routing through steep terrain may exceed the maximal allowed duration,
         * causing a location to appear unreachable.
         * Increasing the maximum travel time for these segments may resolve this issue.
         *
         * Elevation cost profiles are currently used by following street modes:
         * - `BIKE`
         *
         */
        elevationCosts?: ElevationCosts;
        /**
         * geo locations as latitude;longitude,latitude;longitude,...
         */
        many: Array<(string)>;
        /**
         * maximum travel time in seconds
         */
        max: number;
        /**
         * maximum matching distance in meters to match geo coordinates to the street network
         */
        maxMatchingDistance: number;
        /**
         * routing profile to use (currently supported: \`WALK\`, \`BIKE\`, \`CAR\`)
         *
         */
        mode: Mode;
        /**
         * geo location as latitude;longitude
         */
        one: string;
    };
};

export type OneToManyResponse = (Array<Duration>);

export type OneToManyError = unknown;

export type OneToAllData = {
    query: {
        /**
         * Optional. Default is 0 minutes.
         *
         * Additional transfer time reserved for each transfer in minutes.
         *
         */
        additionalTransferTime?: number;
        /**
         * true = all to one,
         * false = one to all
         *
         */
        arriveBy?: boolean;
        /**
         * Optional
         *
         * Average speed for bike routing.
         *
         */
        cyclingSpeed?: CyclingSpeed;
        /**
         * Optional. Default is `NONE`.
         *
         * Set an elevation cost profile, to penalize routes with incline.
         * - `NONE`: No additional costs for elevations. This is the default behavior
         * - `LOW`: Add a low cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if small detours are required.
         * - `HIGH`: Add a high cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if larger detours are required.
         *
         * As using an elevation costs profile will increase the travel duration,
         * routing through steep terrain may exceed the maximal allowed duration,
         * causing a location to appear unreachable.
         * Increasing the maximum travel time for these segments may resolve this issue.
         *
         * The profile is used for routing on both the first and last mile.
         *
         * Elevation cost profiles are currently used by following street modes:
         * - `BIKE`
         *
         */
        elevationCosts?: ElevationCosts;
        /**
         * Optional. Default is 25 meters.
         *
         * Maximum matching distance in meters to match geo coordinates to the street network.
         *
         */
        maxMatchingDistance?: number;
        /**
         * Optional. Default is 15min which is `900`.
         * - `arriveBy=true`: Maximum time in seconds for the street leg at `one` location.
         * - `arriveBy=false`: Currently not used
         * Is limited by server config variable `street_routing_max_prepost_transit_seconds`.
         *
         */
        maxPostTransitTime?: number;
        /**
         * Optional. Default is 15min which is `900`.
         * - `arriveBy=true`: Currently not used
         * - `arriveBy=false`: Maximum time in seconds for the street leg at `one` location.
         * Is limited by server config variable `street_routing_max_prepost_transit_seconds`.
         *
         */
        maxPreTransitTime?: number;
        /**
         * The maximum number of allowed transfers (i.e. interchanges between transit legs,
         * pre- and postTransit do not count as transfers).
         * `maxTransfers=0` searches for direct transit connections without any transfers.
         * If you want to search only for non-transit connections (`FOOT`, `CAR`, etc.),
         * send an empty `transitModes` parameter instead.
         *
         * If not provided, the routing uses the server-side default value
         * which is hardcoded and very high to cover all use cases.
         *
         * *Warning*: Use with care. Setting this too low can lead to
         * optimal (e.g. the fastest) journeys not being found.
         * If this value is too low to reach the destination at all,
         * it can lead to slow routing performance.
         *
         * In plan endpoints before v3, the behavior is off by one,
         * i.e. `maxTransfers=0` only returns non-transit connections.
         *
         */
        maxTransfers?: number;
        /**
         * The maximum travel time in minutes. Defaults to 90. The limit may be increased by the server administrator using `onetoall_max_travel_minutes` option in `config.yml`. See documentation for details.
         */
        maxTravelTime: number;
        /**
         * Optional. Default is 0 minutes.
         *
         * Minimum transfer time for each transfer in minutes.
         *
         */
        minTransferTime?: number;
        /**
         * \`latitude,longitude[,level]\` tuple with
         * - latitude and longitude in degrees
         * - (optional) level: the OSM level (default: 0)
         *
         * OR
         *
         * stop id
         *
         */
        one: string;
        /**
         * Optional. Default is `FOOT`.
         *
         * Accessibility profile to use for pedestrian routing in transfers
         * between transit connections and the first and last mile respectively.
         *
         */
        pedestrianProfile?: PedestrianProfile;
        /**
         * Optional
         *
         * Average speed for pedestrian routing.
         *
         */
        pedestrianSpeed?: PedestrianSpeed;
        /**
         * Optional. Default is `WALK`. The behavior depends on whether `arriveBy` is set:
         * - `arriveBy=true`: Only applies if the `one` place is a coordinate (not a transit stop).
         * - `arriveBy=false`: Currently not used
         *
         * A list of modes that are allowed to be used from the last transit stop to the `to` coordinate. Example: `WALK,BIKE_SHARING`.
         *
         */
        postTransitModes?: Array<Mode>;
        /**
         * Optional. Default is `WALK`. The behavior depends on whether `arriveBy` is set:
         * - `arriveBy=true`: Currently not used
         * - `arriveBy=false`: Only applies if the `one` place is a coordinate (not a transit stop).
         *
         * A list of modes that are allowed to be used from the last transit stop to the `to` coordinate. Example: `WALK,BIKE_SHARING`.
         *
         */
        preTransitModes?: Array<Mode>;
        /**
         * Optional. Default is `false`.
         *
         * If set to `true`, all used transit trips are required to allow bike carriage.
         *
         */
        requireBikeTransport?: boolean;
        /**
         * Optional. Default is `false`.
         *
         * If set to `true`, all used transit trips are required to allow car carriage.
         *
         */
        requireCarTransport?: boolean;
        /**
         * Optional. Defaults to the current time.
         *
         * Departure time ($arriveBy=false) / arrival date ($arriveBy=true),
         *
         */
        time?: string;
        /**
         * Optional. Default is 1.0
         *
         * Factor to multiply minimum required transfer times with.
         * Values smaller than 1.0 are not supported.
         *
         */
        transferTimeFactor?: number;
        /**
         * Optional. Default is `TRANSIT` which allows all transit modes (no restriction).
         * Allowed modes for the transit part. If empty, no transit connections will be computed.
         * For example, this can be used to allow only `SUBURBAN,SUBWAY,TRAM`.
         *
         */
        transitModes?: Array<Mode>;
        /**
         * Optional. Default is `false`.
         *
         * Whether to use transfers routed on OpenStreetMap data.
         *
         */
        useRoutedTransfers?: boolean;
    };
};

export type OneToAllResponse = (Reachable);

export type OneToAllError = (Error);

export type ReverseGeocodeData = {
    query: {
        /**
         * latitude, longitude in degrees
         */
        place: string;
        /**
         * Optional. Default is all types.
         *
         * Only return results of the given type.
         * For example, this can be used to allow only `ADDRESS` and `STOP` results.
         *
         */
        type?: LocationType;
    };
};

export type ReverseGeocodeResponse = (Array<Match>);

export type ReverseGeocodeError = (Error);

export type GeocodeData = {
    query: {
        /**
         * language tags as used in OpenStreetMap
         * (usually ISO 639-1, or ISO 639-2 if there's no ISO 639-1)
         *
         */
        language?: Array<(string)>;
        /**
         * Optional. Filter stops by available transport modes.
         * Defaults to applying no filter.
         *
         */
        mode?: Array<Mode>;
        /**
         * Optional. Used for biasing results towards the coordinate.
         *
         * Format: latitude,longitude in degrees
         *
         */
        place?: string;
        /**
         * Optional. Used for biasing results towards the coordinate. Higher number = higher bias.
         *
         */
        placeBias?: number;
        /**
         * the (potentially partially typed) address to resolve
         */
        text: string;
        /**
         * Optional. Default is all types.
         *
         * Only return results of the given types.
         * For example, this can be used to allow only `ADDRESS` and `STOP` results.
         *
         */
        type?: LocationType;
    };
};

export type GeocodeResponse = (Array<Match>);

export type GeocodeError = (Error);

export type TripData = {
    query: {
        /**
         * Optional. Default is `true`.
         *
         * Controls if a trip with stay-seated transfers is returned:
         * - `joinInterlinedLegs=false`: as several legs (full information about all trip numbers, headsigns, etc.).
         * Legs that do not require a transfer (stay-seated transfer) are marked with `interlineWithPreviousLeg=true`.
         * - `joinInterlinedLegs=true` (default behavior): as only one joined leg containing all stops
         *
         */
        joinInterlinedLegs?: boolean;
        /**
         * language tags as used in OpenStreetMap / GTFS
         * (usually BCP-47 / ISO 639-1, or ISO 639-2 if there's no ISO 639-1)
         *
         */
        language?: Array<(string)>;
        /**
         * trip identifier (e.g. from an itinerary leg or stop event)
         */
        tripId: string;
        /**
         * Optional. Include intermediate stops where passengers can not alight/board according to schedule.
         */
        withScheduledSkippedStops?: boolean;
    };
};

export type TripResponse = (Itinerary);

export type TripError = (Error);

export type StoptimesData = {
    query: {
        /**
         * Optional. Default is `false`.
         *
         * - `arriveBy=true`: the parameters `date` and `time` refer to the arrival time
         * - `arriveBy=false`: the parameters `date` and `time` refer to the departure time
         *
         */
        arriveBy?: boolean;
        /**
         * This parameter will be ignored in case `pageCursor` is set.
         *
         * Optional. Default is
         * - `LATER` for `arriveBy=false`
         * - `EARLIER` for `arriveBy=true`
         *
         * The response will contain the next `n` arrivals / departures
         * in case `EARLIER` is selected and the previous `n`
         * arrivals / departures if `LATER` is selected.
         *
         */
        direction?: 'EARLIER' | 'LATER';
        /**
         * Optional. Default is `false`.
         *
         * If set to `true`, only stations that are phyiscally in the radius are considered.
         * If set to `false`, additionally to the stations in the radius, equivalences with the same name and children are considered.
         *
         */
        exactRadius?: boolean;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Default is `false`. If set to `true`, the following stops are returned
         * for departures and the previous stops are returned for arrivals.
         *
         */
        fetchStops?: boolean;
        /**
         * language tags as used in OpenStreetMap / GTFS
         * (usually BCP-47 / ISO 639-1, or ISO 639-2 if there's no ISO 639-1)
         *
         */
        language?: Array<(string)>;
        /**
         * Optional. Default is all transit modes.
         *
         * Only return arrivals/departures of the given modes.
         *
         */
        mode?: Array<Mode>;
        /**
         * the number of events
         */
        n: number;
        /**
         * Use the cursor to go to the next "page" of stop times.
         * Copy the cursor from the last response and keep the original request as is.
         * This will enable you to search for stop times in the next or previous time-window.
         *
         */
        pageCursor?: string;
        /**
         * Optional. Radius in meters.
         *
         * Default is that only stop times of the parent of the stop itself
         * and all stops with the same name (+ their child stops) are returned.
         *
         * If set, all stops at parent stations and their child stops in the specified radius
         * are returned.
         *
         */
        radius?: number;
        /**
         * stop id of the stop to retrieve departures/arrivals for
         */
        stopId: string;
        /**
         * Optional. Defaults to the current time.
         *
         */
        time?: string;
        /**
         * Optional. Include stoptimes where passengers can not alight/board according to schedule.
         */
        withScheduledSkippedStops?: boolean;
    };
};

export type StoptimesResponse = ({
    /**
     * list of stop times
     */
    stopTimes: Array<StopTime>;
    /**
     * metadata of the requested stop
     */
    place: Place;
    /**
     * Use the cursor to get the previous page of results. Insert the cursor into the request and post it to get the previous page.
     * The previous page is a set of stop times BEFORE the first stop time in the result.
     *
     */
    previousPageCursor: string;
    /**
     * Use the cursor to get the next page of results. Insert the cursor into the request and post it to get the next page.
     * The next page is a set of stop times AFTER the last stop time in this result.
     *
     */
    nextPageCursor: string;
});

export type StoptimesError = (Error);

export type TripsData = {
    query: {
        /**
         * end if the time window
         */
        endTime: string;
        /**
         * latitude,longitude pair of the upper left coordinate
         */
        max: string;
        /**
         * latitude,longitude pair of the lower right coordinate
         */
        min: string;
        /**
         * start of the time window
         */
        startTime: string;
        /**
         * current zoom level
         */
        zoom: number;
    };
};

export type TripsResponse = (Array<TripSegment>);

export type TripsError = (Error);

export type InitialResponse = ({
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    /**
     * zoom level
     */
    zoom: number;
    serverConfig?: ServerConfig;
});

export type InitialError = (Error);

export type StopsData = {
    query: {
        /**
         * latitude,longitude pair of the upper left coordinate
         */
        max: string;
        /**
         * latitude,longitude pair of the lower right coordinate
         */
        min: string;
    };
};

export type StopsResponse = (Array<Place>);

export type StopsError = (Error);

export type LevelsData = {
    query: {
        /**
         * latitude,longitude pair of the upper left coordinate
         */
        max: string;
        /**
         * latitude,longitude pair of the lower right coordinate
         */
        min: string;
    };
};

export type LevelsResponse = (Array<(number)>);

export type LevelsError = (Error);

export type RentalsData = {
    query?: {
        /**
         * latitude,longitude pair of the upper left coordinate
         */
        max?: string;
        /**
         * latitude,longitude pair of the lower right coordinate
         */
        min?: string;
        /**
         * \`latitude,longitude[,level]\` tuple with
         * - latitude and longitude in degrees
         * - (optional) level: the OSM level (ignored, for compatibility reasons)
         *
         * OR
         *
         * stop id
         *
         */
        point?: string;
        /**
         * A list of rental provider groups to return.
         * If both `providerGroups` and `providers` are empty/not specified,
         * all providers in the map section are returned.
         *
         */
        providerGroups?: Array<(string)>;
        /**
         * A list of rental providers to return.
         * If both `providerGroups` and `providers` are empty/not specified,
         * all providers in the map section are returned.
         *
         */
        providers?: Array<(string)>;
        /**
         * Radius around `point` in meters.
         *
         */
        radius?: number;
        /**
         * Optional. Include providers in output. If false, only provider
         * groups are returned.
         *
         * Also affects the providers list for each provider group.
         *
         */
        withProviders?: boolean;
        /**
         * Optional. Include stations in output (requires at least min+max or providers filter).
         */
        withStations?: boolean;
        /**
         * Optional. Include free-floating vehicles in output (requires at least min+max or providers filter).
         */
        withVehicles?: boolean;
        /**
         * Optional. Include geofencing zones in output (requires at least min+max or providers filter).
         */
        withZones?: boolean;
    };
};

export type RentalsResponse = ({
    providerGroups: Array<RentalProviderGroup>;
    providers: Array<RentalProvider>;
    stations: Array<RentalStation>;
    vehicles: Array<RentalVehicle>;
    zones: Array<RentalZone>;
});

export type RentalsError = (Error);

export type TransfersData = {
    query: {
        /**
         * location id
         */
        id: string;
    };
};

export type TransfersResponse = ({
    place: Place;
    root: Place;
    equivalences: Array<Place>;
    /**
     * true if the server has foot transfers computed
     */
    hasFootTransfers: boolean;
    /**
     * true if the server has wheelchair transfers computed
     */
    hasWheelchairTransfers: boolean;
    /**
     * true if the server has car transfers computed
     */
    hasCarTransfers: boolean;
    /**
     * all outgoing transfers of this location
     */
    transfers: Array<Transfer>;
});

export type TransfersError = unknown;