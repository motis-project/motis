// This file is auto-generated by @hey-api/openapi-ts

export const AlertCauseSchema = {
    description: 'Cause of this alert.',
    type: 'string',
    enum: ['UNKNOWN_CAUSE', 'OTHER_CAUSE', 'TECHNICAL_PROBLEM', 'STRIKE', 'DEMONSTRATION', 'ACCIDENT', 'HOLIDAY', 'WEATHER', 'MAINTENANCE', 'CONSTRUCTION', 'POLICE_ACTIVITY', 'MEDICAL_EMERGENCY']
} as const;

export const AlertEffectSchema = {
    description: 'The effect of this problem on the affected entity.',
    type: 'string',
    enum: ['NO_SERVICE', 'REDUCED_SERVICE', 'SIGNIFICANT_DELAYS', 'DETOUR', 'ADDITIONAL_SERVICE', 'MODIFIED_SERVICE', 'OTHER_EFFECT', 'UNKNOWN_EFFECT', 'STOP_MOVED', 'NO_EFFECT', 'ACCESSIBILITY_ISSUE']
} as const;

export const AlertSeverityLevelSchema = {
    description: 'The severity of the alert.',
    type: 'string',
    enum: ['UNKNOWN_SEVERITY', 'INFO', 'WARNING', 'SEVERE']
} as const;

export const TimeRangeSchema = {
    description: `A time interval.
The interval is considered active at time t if t is greater than or equal to the start time and less than the end time.
`,
    type: 'object',
    required: ['start', 'end'],
    properties: {
        start: {
            description: `If missing, the interval starts at minus infinity.
If a TimeRange is provided, either start or end must be provided - both fields cannot be empty.
`,
            type: 'string',
            format: 'date-time'
        },
        end: {
            description: `If missing, the interval ends at plus infinity.
If a TimeRange is provided, either start or end must be provided - both fields cannot be empty.
`,
            type: 'string',
            format: 'date-time'
        }
    }
} as const;

export const AlertSchema = {
    description: 'An alert, indicating some sort of incident in the public transit network.',
    type: 'object',
    required: ['headerText', 'descriptionText'],
    properties: {
        code: {
            type: 'string',
            description: 'Attribute or notice code (e.g. for HRDF or NeTEx)'
        },
        communicationPeriod: {
            description: `Time when the alert should be shown to the user.
If missing, the alert will be shown as long as it appears in the feed.
If multiple ranges are given, the alert will be shown during all of them.
`,
            type: 'array',
            items: {
                '$ref': '#/components/schemas/TimeRange'
            }
        },
        impactPeriod: {
            description: 'Time when the services are affected by the disruption mentioned in the alert.',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/TimeRange'
            }
        },
        cause: {
            '$ref': '#/components/schemas/AlertCause'
        },
        causeDetail: {
            type: 'string',
            description: `Description of the cause of the alert that allows for agency-specific language;
more specific than the Cause.
`
        },
        effect: {
            '$ref': '#/components/schemas/AlertEffect'
        },
        effectDetail: {
            type: 'string',
            description: `Description of the effect of the alert that allows for agency-specific language;
more specific than the Effect.
`
        },
        url: {
            type: 'string',
            description: 'The URL which provides additional information about the alert.'
        },
        headerText: {
            type: 'string',
            description: `Header for the alert. This plain-text string will be highlighted, for example in boldface.
`
        },
        descriptionText: {
            type: 'string',
            description: `Description for the alert.
This plain-text string will be formatted as the body of the alert (or shown on an explicit "expand" request by the user).
The information in the description should add to the information of the header.
`
        },
        ttsHeaderText: {
            type: 'string',
            description: `Text containing the alert's header to be used for text-to-speech implementations.
This field is the text-to-speech version of header_text.
It should contain the same information as headerText but formatted such that it can read as text-to-speech
(for example, abbreviations removed, numbers spelled out, etc.)
`
        },
        ttsDescriptionText: {
            type: 'string',
            description: `Text containing a description for the alert to be used for text-to-speech implementations.
This field is the text-to-speech version of description_text.
It should contain the same information as description_text but formatted such that it can be read as text-to-speech
(for example, abbreviations removed, numbers spelled out, etc.)
`
        },
        severityLevel: {
            description: 'Severity of the alert.',
            '$ref': '#/components/schemas/AlertSeverityLevel'
        },
        imageUrl: {
            description: 'String containing an URL linking to an image.',
            type: 'string'
        },
        imageMediaType: {
            description: `IANA media type as to specify the type of image to be displayed. The type must start with "image/"
`,
            type: 'string'
        },
        imageAlternativeText: {
            description: `Text describing the appearance of the linked image in the image field
(e.g., in case the image can't be displayed or the user can't see the image for accessibility reasons).
See the HTML spec for alt image text.
`,
            type: 'string'
        }
    }
} as const;

export const DurationSchema = {
    description: 'Object containing duration if a path was found or none if no path was found',
    type: 'object',
    properties: {
        duration: {
            type: 'number',
            description: 'duration in seconds if a path was found, otherwise missing'
        },
        distance: {
            type: 'number',
            description: 'distance in meters if a path was found and distance computation was requested, otherwise missing'
        }
    }
} as const;

export const AreaSchema = {
    description: 'Administrative area',
    type: 'object',
    required: ['name', 'adminLevel', 'matched'],
    properties: {
        name: {
            type: 'string',
            description: 'Name of the area'
        },
        adminLevel: {
            type: 'number',
            description: `[OpenStreetMap \`admin_level\`](https://wiki.openstreetmap.org/wiki/Key:admin_level)
of the area
`
        },
        matched: {
            type: 'boolean',
            description: 'Whether this area was matched by the input text'
        },
        unique: {
            type: 'boolean',
            description: `Set for the first area after the \`default\` area that distinguishes areas
if the match is ambiguous regarding (\`default\` area + place name / street [+ house number]).
`
        },
        default: {
            type: 'boolean',
            description: 'Whether this area should be displayed as default area (area with admin level closest 7)'
        }
    }
} as const;

export const TokenSchema = {
    description: 'Matched token range (from index, length)',
    type: 'array',
    minItems: 2,
    maxItems: 2,
    items: {
        type: 'number'
    }
} as const;

export const LocationTypeSchema = {
    description: 'location type',
    type: 'string',
    enum: ['ADDRESS', 'PLACE', 'STOP']
} as const;

export const ModeSchema = {
    description: `# Street modes

  - \`WALK\`
  - \`BIKE\`
  - \`RENTAL\` Experimental. Expect unannounced breaking changes (without version bumps) for all parameters and returned structs.
  - \`CAR\`
  - \`CAR_PARKING\` Experimental. Expect unannounced breaking changes (without version bumps) for all parameters and returned structs.
  - \`CAR_DROPOFF\` Experimental. Expect unannounced breaking changes (without version bumps) for all perameters and returned structs.
  - \`ODM\` on-demand taxis from the Prima+ÖV Project
  - \`RIDE_SHARING\` ride sharing from the Prima+ÖV Project
  - \`FLEX\` flexible transports

# Transit modes

  - \`TRANSIT\`: translates to \`TRAM,FERRY,AIRPLANE,BUS,COACH,RAIL,ODM,FUNICULAR,AERIAL_LIFT,OTHER\`
  - \`TRAM\`: trams
  - \`SUBWAY\`: subway trains (Paris Metro, London Underground, but also NYC Subway, Hamburger Hochbahn, and other non-underground services)
  - \`FERRY\`: ferries
  - \`AIRPLANE\`: airline flights
  - \`BUS\`: short distance buses (does not include \`COACH\`)
  - \`COACH\`: long distance buses (does not include \`BUS\`)
  - \`RAIL\`: translates to \`HIGHSPEED_RAIL,LONG_DISTANCE,NIGHT_RAIL,REGIONAL_RAIL,SUBURBAN,SUBWAY\`
  - \`HIGHSPEED_RAIL\`: long distance high speed trains (e.g. TGV)
  - \`LONG_DISTANCE\`: long distance inter city trains
  - \`NIGHT_RAIL\`: long distance night trains
  - \`REGIONAL_FAST_RAIL\`: deprecated, \`REGIONAL_RAIL\` will be used
  - \`REGIONAL_RAIL\`: regional train
  - \`SUBURBAN\`: suburban trains (e.g. S-Bahn, RER, Elizabeth Line, ...)
  - \`ODM\`: demand responsive transport
  - \`FUNICULAR\`: Funicular. Any rail system designed for steep inclines.
  - \`AERIAL_LIFT\`: Aerial lift, suspended cable car (e.g., gondola lift, aerial tramway). Cable transport where cabins, cars, gondolas or open chairs are suspended by means of one or more cables.
  - \`AREAL_LIFT\`: deprecated
  - \`METRO\`: deprecated
  - \`CABLE_CAR\`: deprecated
`,
    type: 'string',
    enum: ['WALK', 'BIKE', 'RENTAL', 'CAR', 'CAR_PARKING', 'CAR_DROPOFF', 'ODM', 'RIDE_SHARING', 'FLEX', 'DEBUG_BUS_ROUTE', 'DEBUG_RAILWAY_ROUTE', 'DEBUG_FERRY_ROUTE', 'TRANSIT', 'TRAM', 'SUBWAY', 'FERRY', 'AIRPLANE', 'BUS', 'COACH', 'RAIL', 'HIGHSPEED_RAIL', 'LONG_DISTANCE', 'NIGHT_RAIL', 'REGIONAL_FAST_RAIL', 'REGIONAL_RAIL', 'SUBURBAN', 'FUNICULAR', 'AERIAL_LIFT', 'OTHER', 'AREAL_LIFT', 'METRO', 'CABLE_CAR']
} as const;

export const MatchSchema = {
    description: 'GeoCoding match',
    type: 'object',
    required: ['type', 'name', 'id', 'lat', 'lon', 'tokens', 'areas', 'score'],
    properties: {
        type: {
            '$ref': '#/components/schemas/LocationType'
        },
        category: {
            description: `Experimental. Type categories might be adjusted.

For OSM stop locations: the amenity type based on
https://wiki.openstreetmap.org/wiki/OpenStreetMap_Carto/Symbols
`,
            type: 'string'
        },
        tokens: {
            description: 'list of non-overlapping tokens that were matched',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Token'
            }
        },
        name: {
            description: 'name of the location (transit stop / PoI / address)',
            type: 'string'
        },
        id: {
            description: 'unique ID of the location',
            type: 'string'
        },
        lat: {
            description: 'latitude',
            type: 'number'
        },
        lon: {
            description: 'longitude',
            type: 'number'
        },
        level: {
            description: `level according to OpenStreetMap
(at the moment only for public transport)
`,
            type: 'number'
        },
        street: {
            description: 'street name',
            type: 'string'
        },
        houseNumber: {
            description: 'house number',
            type: 'string'
        },
        country: {
            description: 'ISO3166-1 country code from OpenStreetMap',
            type: 'string'
        },
        zip: {
            description: 'zip code',
            type: 'string'
        },
        tz: {
            description: 'timezone name (e.g. "Europe/Berlin")',
            type: 'string'
        },
        areas: {
            description: 'list of areas',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Area'
            }
        },
        score: {
            description: 'score according to the internal scoring system (the scoring algorithm might change in the future)',
            type: 'number'
        },
        modes: {
            description: 'available transport modes for stops',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Mode'
            }
        },
        importance: {
            description: 'importance of a stop, normalized from [0, 1]',
            type: 'number'
        }
    }
} as const;

export const ElevationCostsSchema = {
    description: `Different elevation cost profiles for street routing.
Using a elevation cost profile will prefer routes with a smaller incline and smaller difference in elevation, even if the routed way is longer.

- \`NONE\`: Ignore elevation data for routing. This is the default behavior
- \`LOW\`: Add a low penalty for inclines. This will favor longer paths, if the elevation increase and incline are smaller.
- \`HIGH\`: Add a high penalty for inclines. This will favor even longer paths, if the elevation increase and incline are smaller.
`,
    type: 'string',
    enum: ['NONE', 'LOW', 'HIGH']
} as const;

export const PedestrianProfileSchema = {
    description: 'Different accessibility profiles for pedestrians.',
    type: 'string',
    enum: ['FOOT', 'WHEELCHAIR']
} as const;

export const PedestrianSpeedSchema = {
    description: 'Average speed for pedestrian routing in meters per second',
    type: 'number'
} as const;

export const CyclingSpeedSchema = {
    description: 'Average speed for bike routing in meters per second',
    type: 'number'
} as const;

export const VertexTypeSchema = {
    type: 'string',
    description: `- \`NORMAL\` - latitude / longitude coordinate or address
- \`BIKESHARE\` - bike sharing station
- \`TRANSIT\` - transit stop
`,
    enum: ['NORMAL', 'BIKESHARE', 'TRANSIT']
} as const;

export const PickupDropoffTypeSchema = {
    type: 'string',
    description: `- \`NORMAL\` - entry/exit is possible normally
- \`NOT_ALLOWED\` - entry/exit is not allowed
`,
    enum: ['NORMAL', 'NOT_ALLOWED']
} as const;

export const PlaceSchema = {
    type: 'object',
    required: ['name', 'lat', 'lon', 'level'],
    properties: {
        name: {
            description: 'name of the transit stop / PoI / address',
            type: 'string'
        },
        stopId: {
            description: "The ID of the stop. This is often something that users don't care about.",
            type: 'string'
        },
        parentId: {
            description: "If it's not a root stop, this field contains the `stopId` of the parent stop.",
            type: 'string'
        },
        importance: {
            description: 'The importance of the stop between 0-1.',
            type: 'number'
        },
        lat: {
            description: 'latitude',
            type: 'number'
        },
        lon: {
            description: 'longitude',
            type: 'number'
        },
        level: {
            description: 'level according to OpenStreetMap',
            type: 'number'
        },
        tz: {
            description: 'timezone name (e.g. "Europe/Berlin")',
            type: 'string'
        },
        arrival: {
            description: 'arrival time',
            type: 'string',
            format: 'date-time'
        },
        departure: {
            description: 'departure time',
            type: 'string',
            format: 'date-time'
        },
        scheduledArrival: {
            description: 'scheduled arrival time',
            type: 'string',
            format: 'date-time'
        },
        scheduledDeparture: {
            description: 'scheduled departure time',
            type: 'string',
            format: 'date-time'
        },
        scheduledTrack: {
            description: 'scheduled track from the static schedule timetable dataset',
            type: 'string'
        },
        track: {
            description: `The current track/platform information, updated with real-time updates if available. 
Can be missing if neither real-time updates nor the schedule timetable contains track information.
`,
            type: 'string'
        },
        description: {
            description: 'description of the location that provides more detailed information',
            type: 'string'
        },
        vertexType: {
            '$ref': '#/components/schemas/VertexType'
        },
        pickupType: {
            description: 'Type of pickup. It could be disallowed due to schedule, skipped stops or cancellations.',
            '$ref': '#/components/schemas/PickupDropoffType'
        },
        dropoffType: {
            description: 'Type of dropoff. It could be disallowed due to schedule, skipped stops or cancellations.',
            '$ref': '#/components/schemas/PickupDropoffType'
        },
        cancelled: {
            description: 'Whether this stop is cancelled due to the realtime situation.',
            type: 'boolean'
        },
        alerts: {
            description: 'Alerts for this stop.',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Alert'
            }
        },
        flex: {
            description: 'for `FLEX` transports, the flex location area or location group name',
            type: 'string'
        },
        flexId: {
            description: 'for `FLEX` transports, the flex location area ID or location group ID',
            type: 'string'
        },
        flexStartPickupDropOffWindow: {
            description: 'Time that on-demand service becomes available',
            type: 'string',
            format: 'date-time'
        },
        flexEndPickupDropOffWindow: {
            description: 'Time that on-demand service ends',
            type: 'string',
            format: 'date-time'
        },
        modes: {
            description: 'available transport modes for stops',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Mode'
            }
        }
    }
} as const;

export const ReachablePlaceSchema = {
    description: 'Place reachable by One-to-All',
    type: 'object',
    properties: {
        place: {
            '$ref': '#/components/schemas/Place',
            description: 'Place reached by One-to-All'
        },
        duration: {
            type: 'integer',
            description: 'Total travel duration'
        },
        k: {
            type: 'integer',
            description: `k is the smallest number, for which a journey with the shortest duration and at most k-1 transfers exist.
You can think of k as the number of connections used.

In more detail:

k=0: No connection, e.g. for the one location
k=1: Direct connection
k=2: Connection with 1 transfer
`
        }
    }
} as const;

export const ReachableSchema = {
    description: 'Object containing all reachable places by One-to-All search',
    type: 'object',
    properties: {
        one: {
            '$ref': '#/components/schemas/Place',
            description: 'One location used in One-to-All search'
        },
        all: {
            description: 'List of locations reachable by One-to-All',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/ReachablePlace'
            }
        }
    }
} as const;

export const StopTimeSchema = {
    description: 'departure or arrival event at a stop',
    type: 'object',
    required: ['place', 'mode', 'realTime', 'headsign', 'tripFrom', 'tripTo', 'agencyId', 'agencyName', 'agencyUrl', 'tripId', 'routeId', 'directionId', 'routeShortName', 'routeLongName', 'tripShortName', 'displayName', 'pickupDropoffType', 'cancelled', 'tripCancelled', 'source'],
    properties: {
        place: {
            '$ref': '#/components/schemas/Place',
            description: 'information about the stop place and time'
        },
        mode: {
            '$ref': '#/components/schemas/Mode',
            description: 'Transport mode for this leg'
        },
        realTime: {
            description: 'Whether there is real-time data about this leg',
            type: 'boolean'
        },
        headsign: {
            description: `The headsign of the bus or train being used.
For non-transit legs, null
`,
            type: 'string'
        },
        tripFrom: {
            description: 'first stop of this trip',
            '$ref': '#/components/schemas/Place'
        },
        tripTo: {
            description: 'final stop of this trip',
            '$ref': '#/components/schemas/Place'
        },
        agencyId: {
            type: 'string'
        },
        agencyName: {
            type: 'string'
        },
        agencyUrl: {
            type: 'string'
        },
        routeId: {
            type: 'string'
        },
        routeUrl: {
            type: 'string'
        },
        directionId: {
            type: 'string'
        },
        routeColor: {
            type: 'string'
        },
        routeTextColor: {
            type: 'string'
        },
        tripId: {
            type: 'string'
        },
        routeType: {
            type: 'integer'
        },
        routeShortName: {
            type: 'string'
        },
        routeLongName: {
            type: 'string'
        },
        tripShortName: {
            type: 'string'
        },
        displayName: {
            type: 'string'
        },
        previousStops: {
            type: 'array',
            description: `Experimental. Expect unannounced breaking changes (without version bumps).

Stops on the trips before this stop. Returned only if \`fetchStop\` and \`arriveBy\` are \`true\`.
`,
            items: {
                '$ref': '#/components/schemas/Place'
            }
        },
        nextStops: {
            type: 'array',
            description: `Experimental. Expect unannounced breaking changes (without version bumps).

Stops on the trips after this stop. Returned only if \`fetchStop\` is \`true\` and \`arriveBy\` is \`false\`.
`,
            items: {
                '$ref': '#/components/schemas/Place'
            }
        },
        pickupDropoffType: {
            description: 'Type of pickup (for departures) or dropoff (for arrivals), may be disallowed either due to schedule, skipped stops or cancellations',
            '$ref': '#/components/schemas/PickupDropoffType'
        },
        cancelled: {
            description: 'Whether the departure/arrival is cancelled due to the realtime situation (either because the stop is skipped or because the entire trip is cancelled).',
            type: 'boolean'
        },
        tripCancelled: {
            description: 'Whether the entire trip is cancelled due to the realtime situation.',
            type: 'boolean'
        },
        source: {
            description: 'Filename and line number where this trip is from',
            type: 'string'
        }
    }
} as const;

export const TripInfoSchema = {
    description: 'trip id and name',
    type: 'object',
    required: ['tripId'],
    properties: {
        tripId: {
            description: 'trip ID (dataset trip id prefixed with the dataset tag)',
            type: 'string'
        },
        routeShortName: {
            description: 'trip display name (api version < 4)',
            type: 'string'
        },
        displayName: {
            description: 'trip display name (api version >= 4)',
            type: 'string'
        }
    }
} as const;

export const TripSegmentSchema = {
    description: 'trip segment between two stops to show a trip on a map',
    type: 'object',
    required: ['trips', 'mode', 'distance', 'from', 'to', 'departure', 'arrival', 'scheduledArrival', 'scheduledDeparture', 'realTime', 'polyline'],
    properties: {
        trips: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/TripInfo'
            }
        },
        routeColor: {
            type: 'string'
        },
        mode: {
            '$ref': '#/components/schemas/Mode',
            description: 'Transport mode for this leg'
        },
        distance: {
            type: 'number',
            description: 'distance in meters'
        },
        from: {
            '$ref': '#/components/schemas/Place'
        },
        to: {
            '$ref': '#/components/schemas/Place'
        },
        departure: {
            description: 'departure time',
            type: 'string',
            format: 'date-time'
        },
        arrival: {
            description: 'arrival time',
            type: 'string',
            format: 'date-time'
        },
        scheduledDeparture: {
            description: 'scheduled departure time',
            type: 'string',
            format: 'date-time'
        },
        scheduledArrival: {
            description: 'scheduled arrival time',
            type: 'string',
            format: 'date-time'
        },
        realTime: {
            description: 'Whether there is real-time data about this leg',
            type: 'boolean'
        },
        polyline: {
            description: 'Google polyline encoded coordinate sequence (with precision 5) where the trip travels on this segment.',
            type: 'string'
        }
    }
} as const;

export const DirectionSchema = {
    type: 'string',
    enum: ['DEPART', 'HARD_LEFT', 'LEFT', 'SLIGHTLY_LEFT', 'CONTINUE', 'SLIGHTLY_RIGHT', 'RIGHT', 'HARD_RIGHT', 'CIRCLE_CLOCKWISE', 'CIRCLE_COUNTERCLOCKWISE', 'STAIRS', 'ELEVATOR', 'UTURN_LEFT', 'UTURN_RIGHT']
} as const;

export const EncodedPolylineSchema = {
    type: 'object',
    required: ['points', 'precision', 'length'],
    properties: {
        points: {
            description: 'The encoded points of the polyline using the Google polyline encoding.',
            type: 'string'
        },
        precision: {
            description: `The precision of the returned polyline (7 for /v1, 6 for /v2)
Be aware that with precision 7, coordinates with |longitude| > 107.37 are undefined/will overflow.
`,
            type: 'integer'
        },
        length: {
            description: 'The number of points in the string',
            type: 'integer',
            minimum: 0
        }
    }
} as const;

export const StepInstructionSchema = {
    type: 'object',
    required: ['fromLevel', 'toLevel', 'polyline', 'relativeDirection', 'distance', 'streetName', 'exit', 'stayOn', 'area'],
    properties: {
        relativeDirection: {
            '$ref': '#/components/schemas/Direction'
        },
        distance: {
            description: 'The distance in meters that this step takes.',
            type: 'number'
        },
        fromLevel: {
            description: 'level where this segment starts, based on OpenStreetMap data',
            type: 'number'
        },
        toLevel: {
            description: 'level where this segment starts, based on OpenStreetMap data',
            type: 'number'
        },
        osmWay: {
            description: 'OpenStreetMap way index',
            type: 'integer'
        },
        polyline: {
            '$ref': '#/components/schemas/EncodedPolyline'
        },
        streetName: {
            description: 'The name of the street.',
            type: 'string'
        },
        exit: {
            description: `Not implemented!
When exiting a highway or traffic circle, the exit name/number.
`,
            type: 'string'
        },
        stayOn: {
            description: `Not implemented!
Indicates whether or not a street changes direction at an intersection.
`,
            type: 'boolean'
        },
        area: {
            description: `Not implemented!
This step is on an open area, such as a plaza or train platform,
and thus the directions should say something like "cross"
`,
            type: 'boolean'
        },
        toll: {
            description: 'Indicates that a fee must be paid by general traffic to use a road, road bridge or road tunnel.',
            type: 'boolean'
        },
        accessRestriction: {
            description: `Experimental. Indicates whether access to this part of the route is restricted.
See: https://wiki.openstreetmap.org/wiki/Conditional_restrictions
`,
            type: 'string'
        },
        elevationUp: {
            type: 'integer',
            description: 'incline in meters across this path segment'
        },
        elevationDown: {
            type: 'integer',
            description: 'decline in meters across this path segment'
        }
    }
} as const;

export const RentalFormFactorSchema = {
    type: 'string',
    enum: ['BICYCLE', 'CARGO_BICYCLE', 'CAR', 'MOPED', 'SCOOTER_STANDING', 'SCOOTER_SEATED', 'OTHER']
} as const;

export const RentalPropulsionTypeSchema = {
    type: 'string',
    enum: ['HUMAN', 'ELECTRIC_ASSIST', 'ELECTRIC', 'COMBUSTION', 'COMBUSTION_DIESEL', 'HYBRID', 'PLUG_IN_HYBRID', 'HYDROGEN_FUEL_CELL']
} as const;

export const RentalReturnConstraintSchema = {
    type: 'string',
    enum: ['NONE', 'ANY_STATION', 'ROUNDTRIP_STATION']
} as const;

export const RentalSchema = {
    description: 'Vehicle rental',
    type: 'object',
    required: ['providerId', 'providerGroupId', 'systemId'],
    properties: {
        providerId: {
            type: 'string',
            description: 'Rental provider ID'
        },
        providerGroupId: {
            type: 'string',
            description: 'Rental provider group ID'
        },
        systemId: {
            type: 'string',
            description: 'Vehicle share system ID'
        },
        systemName: {
            type: 'string',
            description: 'Vehicle share system name'
        },
        url: {
            type: 'string',
            description: 'URL of the vehicle share system'
        },
        color: {
            type: 'string',
            description: `Color associated with this provider, in hexadecimal RGB format
(e.g. "#FF0000" for red). Can be empty.
`
        },
        stationName: {
            type: 'string',
            description: 'Name of the station'
        },
        fromStationName: {
            type: 'string',
            description: 'Name of the station where the vehicle is picked up (empty for free floating vehicles)'
        },
        toStationName: {
            type: 'string',
            description: 'Name of the station where the vehicle is returned (empty for free floating vehicles)'
        },
        rentalUriAndroid: {
            type: 'string',
            description: 'Rental URI for Android (deep link to the specific station or vehicle)'
        },
        rentalUriIOS: {
            type: 'string',
            description: 'Rental URI for iOS (deep link to the specific station or vehicle)'
        },
        rentalUriWeb: {
            type: 'string',
            description: 'Rental URI for web (deep link to the specific station or vehicle)'
        },
        formFactor: {
            '$ref': '#/components/schemas/RentalFormFactor'
        },
        propulsionType: {
            '$ref': '#/components/schemas/RentalPropulsionType'
        },
        returnConstraint: {
            '$ref': '#/components/schemas/RentalReturnConstraint'
        }
    }
} as const;

export const MultiPolygonSchema = {
    type: 'array',
    description: `A multi-polygon contains a number of polygons, each containing a number
of rings, which are encoded as polylines (with precision 6).

For each polygon, the first ring is the outer ring, all subsequent rings
are inner rings (holes).
`,
    items: {
        type: 'array',
        items: {
            '$ref': '#/components/schemas/EncodedPolyline'
        }
    }
} as const;

export const RentalZoneRestrictionsSchema = {
    type: 'object',
    required: ['vehicleTypeIdxs', 'rideStartAllowed', 'rideEndAllowed', 'rideThroughAllowed'],
    properties: {
        vehicleTypeIdxs: {
            type: 'array',
            description: `List of vehicle types (as indices into the provider's vehicle types
array) to which these restrictions apply.
If empty, the restrictions apply to all vehicle types of the provider.
`,
            items: {
                type: 'integer'
            }
        },
        rideStartAllowed: {
            type: 'boolean',
            description: 'whether the ride is allowed to start in this zone'
        },
        rideEndAllowed: {
            type: 'boolean',
            description: 'whether the ride is allowed to end in this zone'
        },
        rideThroughAllowed: {
            type: 'boolean',
            description: 'whether the ride is allowed to pass through this zone'
        },
        stationParking: {
            type: 'boolean',
            description: 'whether vehicles can only be parked at stations in this zone'
        }
    }
} as const;

export const RentalVehicleTypeSchema = {
    type: 'object',
    required: ['id', 'formFactor', 'propulsionType', 'returnConstraint', 'returnConstraintGuessed'],
    properties: {
        id: {
            type: 'string',
            description: 'Unique identifier of the vehicle type (unique within the provider)'
        },
        name: {
            type: 'string',
            description: 'Public name of the vehicle type (can be empty)'
        },
        formFactor: {
            '$ref': '#/components/schemas/RentalFormFactor'
        },
        propulsionType: {
            '$ref': '#/components/schemas/RentalPropulsionType'
        },
        returnConstraint: {
            '$ref': '#/components/schemas/RentalReturnConstraint'
        },
        returnConstraintGuessed: {
            type: 'boolean',
            description: 'Whether the return constraint was guessed instead of being specified by the rental provider'
        }
    }
} as const;

export const RentalProviderSchema = {
    type: 'object',
    required: ['id', 'name', 'groupId', 'bbox', 'vehicleTypes', 'formFactors', 'defaultRestrictions', 'globalGeofencingRules'],
    properties: {
        id: {
            type: 'string',
            description: 'Unique identifier of the rental provider'
        },
        name: {
            type: 'string',
            description: 'Name of the provider to be displayed to customers'
        },
        groupId: {
            type: 'string',
            description: 'Id of the rental provider group this provider belongs to'
        },
        operator: {
            type: 'string',
            description: 'Name of the system operator'
        },
        url: {
            type: 'string',
            description: 'URL of the vehicle share system'
        },
        purchaseUrl: {
            type: 'string',
            description: 'URL where a customer can purchase a membership'
        },
        color: {
            type: 'string',
            description: `Color associated with this provider, in hexadecimal RGB format
(e.g. "#FF0000" for red). Can be empty.
`
        },
        bbox: {
            type: 'array',
            description: `Bounding box of the area covered by this rental provider,
[west, south, east, north] as [lon, lat, lon, lat]
`,
            minItems: 4,
            maxItems: 4,
            items: {
                type: 'number'
            }
        },
        vehicleTypes: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/RentalVehicleType'
            }
        },
        formFactors: {
            type: 'array',
            description: 'List of form factors offered by this provider',
            items: {
                '$ref': '#/components/schemas/RentalFormFactor'
            }
        },
        defaultRestrictions: {
            '$ref': '#/components/schemas/RentalZoneRestrictions'
        },
        globalGeofencingRules: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/RentalZoneRestrictions'
            }
        }
    }
} as const;

export const RentalProviderGroupSchema = {
    type: 'object',
    required: ['id', 'name', 'providers', 'formFactors'],
    properties: {
        id: {
            type: 'string',
            description: 'Unique identifier of the rental provider group'
        },
        name: {
            type: 'string',
            description: 'Name of the provider group to be displayed to customers'
        },
        color: {
            type: 'string',
            description: `Color associated with this provider group, in hexadecimal RGB format
(e.g. "#FF0000" for red). Can be empty.
`
        },
        providers: {
            type: 'array',
            description: 'List of rental provider IDs that belong to this group',
            items: {
                type: 'string'
            }
        },
        formFactors: {
            type: 'array',
            description: 'List of form factors offered by this provider group',
            items: {
                '$ref': '#/components/schemas/RentalFormFactor'
            }
        }
    }
} as const;

export const RentalStationSchema = {
    type: 'object',
    required: ['id', 'providerId', 'providerGroupId', 'name', 'lat', 'lon', 'isRenting', 'isReturning', 'numVehiclesAvailable', 'formFactors', 'vehicleTypesAvailable', 'vehicleDocksAvailable', 'bbox'],
    properties: {
        id: {
            type: 'string',
            description: 'Unique identifier of the rental station'
        },
        providerId: {
            type: 'string',
            description: 'Unique identifier of the rental provider'
        },
        providerGroupId: {
            type: 'string',
            description: 'Unique identifier of the rental provider group'
        },
        name: {
            type: 'string',
            description: 'Public name of the station'
        },
        lat: {
            description: 'latitude',
            type: 'number'
        },
        lon: {
            description: 'longitude',
            type: 'number'
        },
        address: {
            type: 'string',
            description: 'Address where the station is located'
        },
        crossStreet: {
            type: 'string',
            description: 'Cross street or landmark where the station is located'
        },
        rentalUriAndroid: {
            type: 'string',
            description: 'Rental URI for Android (deep link to the specific station)'
        },
        rentalUriIOS: {
            type: 'string',
            description: 'Rental URI for iOS (deep link to the specific station)'
        },
        rentalUriWeb: {
            type: 'string',
            description: 'Rental URI for web (deep link to the specific station)'
        },
        isRenting: {
            type: 'boolean',
            description: 'true if vehicles can be rented from this station, false if it is temporarily out of service'
        },
        isReturning: {
            type: 'boolean',
            description: 'true if vehicles can be returned to this station, false if it is temporarily out of service'
        },
        numVehiclesAvailable: {
            type: 'integer',
            description: 'Number of vehicles available for rental at this station'
        },
        formFactors: {
            type: 'array',
            description: 'List of form factors available for rental and/or return at this station',
            items: {
                '$ref': '#/components/schemas/RentalFormFactor'
            }
        },
        vehicleTypesAvailable: {
            type: 'object',
            description: 'List of vehicle types currently available at this station (vehicle type ID -> count)',
            additionalProperties: {
                type: 'integer'
            }
        },
        vehicleDocksAvailable: {
            type: 'object',
            description: 'List of vehicle docks currently available at this station (vehicle type ID -> count)',
            additionalProperties: {
                type: 'integer'
            }
        },
        stationArea: {
            '$ref': '#/components/schemas/MultiPolygon'
        },
        bbox: {
            type: 'array',
            description: `Bounding box of the area covered by this station,
[west, south, east, north] as [lon, lat, lon, lat]
`,
            minItems: 4,
            maxItems: 4,
            items: {
                type: 'number'
            }
        }
    }
} as const;

export const RentalVehicleSchema = {
    type: 'object',
    required: ['id', 'providerId', 'providerGroupId', 'typeId', 'lat', 'lon', 'formFactor', 'propulsionType', 'returnConstraint', 'isReserved', 'isDisabled'],
    properties: {
        id: {
            type: 'string',
            description: 'Unique identifier of the rental vehicle'
        },
        providerId: {
            type: 'string',
            description: 'Unique identifier of the rental provider'
        },
        providerGroupId: {
            type: 'string',
            description: 'Unique identifier of the rental provider group'
        },
        typeId: {
            type: 'string',
            description: 'Vehicle type ID (unique within the provider)'
        },
        lat: {
            description: 'latitude',
            type: 'number'
        },
        lon: {
            description: 'longitude',
            type: 'number'
        },
        formFactor: {
            '$ref': '#/components/schemas/RentalFormFactor'
        },
        propulsionType: {
            '$ref': '#/components/schemas/RentalPropulsionType'
        },
        returnConstraint: {
            '$ref': '#/components/schemas/RentalReturnConstraint'
        },
        stationId: {
            type: 'string',
            description: 'Station ID if the vehicle is currently at a station'
        },
        homeStationId: {
            type: 'string',
            description: 'Station ID where the vehicle must be returned, if applicable'
        },
        isReserved: {
            type: 'boolean',
            description: 'true if the vehicle is currently reserved by a customer, false otherwise'
        },
        isDisabled: {
            type: 'boolean',
            description: 'true if the vehicle is out of service, false otherwise'
        },
        rentalUriAndroid: {
            type: 'string',
            description: 'Rental URI for Android (deep link to the specific vehicle)'
        },
        rentalUriIOS: {
            type: 'string',
            description: 'Rental URI for iOS (deep link to the specific vehicle)'
        },
        rentalUriWeb: {
            type: 'string',
            description: 'Rental URI for web (deep link to the specific vehicle)'
        }
    }
} as const;

export const RentalZoneSchema = {
    type: 'object',
    required: ['providerId', 'providerGroupId', 'z', 'bbox', 'area', 'rules'],
    properties: {
        providerId: {
            type: 'string',
            description: 'Unique identifier of the rental provider'
        },
        providerGroupId: {
            type: 'string',
            description: 'Unique identifier of the rental provider group'
        },
        name: {
            type: 'string',
            description: 'Public name of the geofencing zone'
        },
        z: {
            type: 'integer',
            description: 'Zone precedence / z-index (higher number = higher precedence)'
        },
        bbox: {
            type: 'array',
            description: `Bounding box of the area covered by this zone,
[west, south, east, north] as [lon, lat, lon, lat]
`,
            minItems: 4,
            maxItems: 4,
            items: {
                type: 'number'
            }
        },
        area: {
            '$ref': '#/components/schemas/MultiPolygon'
        },
        rules: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/RentalZoneRestrictions'
            }
        }
    }
} as const;

export const LegSchema = {
    type: 'object',
    required: ['mode', 'startTime', 'endTime', 'scheduledStartTime', 'scheduledEndTime', 'realTime', 'scheduled', 'duration', 'from', 'to', 'legGeometry'],
    properties: {
        mode: {
            '$ref': '#/components/schemas/Mode',
            description: 'Transport mode for this leg'
        },
        from: {
            '$ref': '#/components/schemas/Place'
        },
        to: {
            '$ref': '#/components/schemas/Place'
        },
        duration: {
            description: `Leg duration in seconds

If leg is footpath:
  The footpath duration is derived from the default footpath
  duration using the query parameters \`transferTimeFactor\` and
  \`additionalTransferTime\` as follows:
  \`leg.duration = defaultDuration * transferTimeFactor + additionalTransferTime.\`
  In case the defaultDuration is needed, it can be calculated by
  \`defaultDuration = (leg.duration - additionalTransferTime) / transferTimeFactor\`.
  Note that the default values are \`transferTimeFactor = 1\` and
  \`additionalTransferTime = 0\` in case they are not explicitly
  provided in the query.
`,
            type: 'integer'
        },
        startTime: {
            type: 'string',
            format: 'date-time',
            description: 'leg departure time'
        },
        endTime: {
            type: 'string',
            format: 'date-time',
            description: 'leg arrival time'
        },
        scheduledStartTime: {
            type: 'string',
            format: 'date-time',
            description: 'scheduled leg departure time'
        },
        scheduledEndTime: {
            type: 'string',
            format: 'date-time',
            description: 'scheduled leg arrival time'
        },
        realTime: {
            description: 'Whether there is real-time data about this leg',
            type: 'boolean'
        },
        scheduled: {
            description: `Whether this leg was originally scheduled to run or is an additional service.
Scheduled times will equal realtime times in this case.
`,
            type: 'boolean'
        },
        distance: {
            description: 'For non-transit legs the distance traveled while traversing this leg in meters.',
            type: 'number'
        },
        interlineWithPreviousLeg: {
            description: 'For transit legs, if the rider should stay on the vehicle as it changes route names.',
            type: 'boolean'
        },
        headsign: {
            description: `For transit legs, the headsign of the bus or train being used.
For non-transit legs, null
`,
            type: 'string'
        },
        tripFrom: {
            description: 'first stop of this trip',
            '$ref': '#/components/schemas/Place'
        },
        tripTo: {
            description: 'final stop of this trip (can differ from headsign)',
            '$ref': '#/components/schemas/Place'
        },
        routeId: {
            type: 'string'
        },
        routeUrl: {
            type: 'string'
        },
        directionId: {
            type: 'string'
        },
        routeColor: {
            type: 'string'
        },
        routeTextColor: {
            type: 'string'
        },
        routeType: {
            type: 'integer'
        },
        agencyName: {
            type: 'string'
        },
        agencyUrl: {
            type: 'string'
        },
        agencyId: {
            type: 'string'
        },
        tripId: {
            type: 'string'
        },
        routeShortName: {
            type: 'string'
        },
        routeLongName: {
            type: 'string'
        },
        tripShortName: {
            type: 'string'
        },
        displayName: {
            type: 'string'
        },
        cancelled: {
            description: 'Whether this trip is cancelled',
            type: 'boolean'
        },
        source: {
            description: 'Filename and line number where this trip is from',
            type: 'string'
        },
        intermediateStops: {
            description: `For transit legs, intermediate stops between the Place where the leg originates
and the Place where the leg ends. For non-transit legs, null.
`,
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Place'
            }
        },
        legGeometry: {
            '$ref': '#/components/schemas/EncodedPolyline'
        },
        steps: {
            description: `A series of turn by turn instructions
used for walking, biking and driving.
`,
            type: 'array',
            items: {
                '$ref': '#/components/schemas/StepInstruction'
            }
        },
        rental: {
            '$ref': '#/components/schemas/Rental'
        },
        fareTransferIndex: {
            type: 'integer',
            description: `Index into \`Itinerary.fareTransfers\` array
to identify which fare transfer this leg belongs to
`
        },
        effectiveFareLegIndex: {
            type: 'integer',
            description: `Index into the \`Itinerary.fareTransfers[fareTransferIndex].effectiveFareLegProducts\` array
to identify which effective fare leg this itinerary leg belongs to
`
        },
        alerts: {
            description: 'Alerts for this stop.',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Alert'
            }
        },
        loopedCalendarSince: {
            description: `If set, this attribute indicates that this trip has been expanded
beyond the feed end date (enabled by config flag \`timetable.dataset.extend_calendar\`)
by looping active weekdays, e.g. from calendar.txt in GTFS.
`,
            type: 'string',
            format: 'date-time'
        },
        bikesAllowed: {
            description: `Whether bikes can be carried on this leg.
`,
            type: 'boolean'
        }
    }
} as const;

export const RiderCategorySchema = {
    type: 'object',
    required: ['riderCategoryName', 'isDefaultFareCategory'],
    properties: {
        riderCategoryName: {
            description: 'Rider category name as displayed to the rider.',
            type: 'string'
        },
        isDefaultFareCategory: {
            description: 'Specifies if this category should be considered the default (i.e. the main category displayed to riders).',
            type: 'boolean'
        },
        eligibilityUrl: {
            description: 'URL to a web page providing detailed information about the rider category and/or its eligibility criteria.',
            type: 'string'
        }
    }
} as const;

export const FareMediaTypeSchema = {
    type: 'string',
    enum: ['NONE', 'PAPER_TICKET', 'TRANSIT_CARD', 'CONTACTLESS_EMV', 'MOBILE_APP'],
    description: `- \`NONE\`: No fare media involved (e.g., cash payment)
- \`PAPER_TICKET\`: Physical paper ticket
- \`TRANSIT_CARD\`: Physical transit card with stored value
- \`CONTACTLESS_EMV\`: cEMV (contactless payment)
- \`MOBILE_APP\`: Mobile app with virtual transit cards/passes
`
} as const;

export const FareMediaSchema = {
    type: 'object',
    required: ['fareMediaType'],
    properties: {
        fareMediaName: {
            description: 'Name of the fare media. Required for transit cards and mobile apps.',
            type: 'string'
        },
        fareMediaType: {
            description: 'The type of fare media.',
            '$ref': '#/components/schemas/FareMediaType'
        }
    }
} as const;

export const FareProductSchema = {
    type: 'object',
    required: ['name', 'amount', 'currency'],
    properties: {
        name: {
            description: 'The name of the fare product as displayed to riders.',
            type: 'string'
        },
        amount: {
            description: 'The cost of the fare product. May be negative to represent transfer discounts. May be zero to represent a fare product that is free.',
            type: 'number'
        },
        currency: {
            description: 'ISO 4217 currency code. The currency of the cost of the fare product.',
            type: 'string'
        },
        riderCategory: {
            '$ref': '#/components/schemas/RiderCategory'
        },
        media: {
            '$ref': '#/components/schemas/FareMedia'
        }
    }
} as const;

export const FareTransferRuleSchema = {
    type: 'string',
    enum: ['A_AB', 'A_AB_B', 'AB']
} as const;

export const FareTransferSchema = {
    type: 'object',
    description: `The concept is derived from: https://gtfs.org/documentation/schedule/reference/#fare_transfer_rulestxt

Terminology:
  - **Leg**: An itinerary leg as described by the \`Leg\` type of this API description.
  - **Effective Fare Leg**: Itinerary legs can be joined together to form one *effective fare leg*.
  - **Fare Transfer**: A fare transfer groups two or more effective fare legs.
  - **A** is the first *effective fare leg* of potentially multiple consecutive legs contained in a fare transfer
  - **B** is any *effective fare leg* following the first *effective fare leg* in this transfer
  - **AB** are all changes between *effective fare legs* contained in this transfer

The fare transfer rule is used to derive the final set of products of the itinerary legs contained in this transfer:
  - A_AB means that any product from the first effective fare leg combined with the product attached to the transfer itself (AB) which can be empty (= free). Note that all subsequent effective fare leg products need to be ignored in this case.
  - A_AB_B mean that a product for each effective fare leg needs to be purchased in a addition to the product attached to the transfer itself (AB) which can be empty (= free)
  - AB only the transfer product itself has to be purchased. Note that all fare products attached to the contained effective fare legs need to be ignored in this case.

An itinerary \`Leg\` references the index of the fare transfer and the index of the effective fare leg in this transfer it belongs to.
`,
    required: ['effectiveFareLegProducts'],
    properties: {
        rule: {
            '$ref': '#/components/schemas/FareTransferRule'
        },
        transferProducts: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/FareProduct'
            }
        },
        effectiveFareLegProducts: {
            description: `Lists all valid fare products for the effective fare legs.
This is an \`array<array<FareProduct>>\` where the inner array
lists all possible fare products that would cover this effective fare leg.
Each "effective fare leg" can have multiple options for adult/child/weekly/monthly/day/one-way tickets etc.
You can see the outer array as AND (you need one ticket for each effective fare leg (\`A_AB_B\`), the first effective fare leg (\`A_AB\`) or no fare leg at all but only the transfer product (\`AB\`)
and the inner array as OR (you can choose which ticket to buy)
`,
            type: 'array',
            items: {
                type: 'array',
                items: {
                    type: 'array',
                    items: {
                        '$ref': '#/components/schemas/FareProduct'
                    }
                }
            }
        }
    }
} as const;

export const ItinerarySchema = {
    type: 'object',
    required: ['duration', 'startTime', 'endTime', 'transfers', 'legs'],
    properties: {
        duration: {
            description: 'journey duration in seconds',
            type: 'integer'
        },
        startTime: {
            type: 'string',
            format: 'date-time',
            description: 'journey departure time'
        },
        endTime: {
            type: 'string',
            format: 'date-time',
            description: 'journey arrival time'
        },
        transfers: {
            type: 'integer',
            description: 'The number of transfers this trip has.'
        },
        legs: {
            description: 'Journey legs',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Leg'
            }
        },
        fareTransfers: {
            description: 'Fare information',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/FareTransfer'
            }
        }
    }
} as const;

export const TransferSchema = {
    description: 'transfer from one location to another',
    type: 'object',
    required: ['to'],
    properties: {
        to: {
            '$ref': '#/components/schemas/Place'
        },
        default: {
            type: 'number',
            description: `optional; missing if the GTFS did not contain a transfer
transfer duration in minutes according to GTFS (+heuristics)
`
        },
        foot: {
            type: 'number',
            description: `optional; missing if no path was found (timetable / osr)
transfer duration in minutes for the foot profile
`
        },
        footRouted: {
            type: 'number',
            description: `optional; missing if no path was found with foot routing
transfer duration in minutes for the foot profile
`
        },
        wheelchair: {
            type: 'number',
            description: `optional; missing if no path was found with the wheelchair profile 
transfer duration in minutes for the wheelchair profile
`
        },
        wheelchairRouted: {
            type: 'number',
            description: `optional; missing if no path was found with the wheelchair profile
transfer duration in minutes for the wheelchair profile
`
        },
        wheelchairUsesElevator: {
            type: 'boolean',
            description: `optional; missing if no path was found with the wheelchair profile
true if the wheelchair path uses an elevator
`
        },
        car: {
            type: 'number',
            description: `optional; missing if no path was found with car routing
transfer duration in minutes for the car profile
`
        }
    }
} as const;

export const OneToManyParamsSchema = {
    type: 'object',
    required: ['one', 'many', 'mode', 'max', 'maxMatchingDistance', 'elevationCosts', 'arriveBy', 'withDistance'],
    properties: {
        one: {
            description: 'geo location as latitude;longitude',
            type: 'string'
        },
        many: {
            description: `geo locations as latitude;longitude,latitude;longitude,...

The number of accepted locations is limited by server config variable \`onetomany_max_many\`.
`,
            type: 'array',
            items: {
                type: 'string'
            },
            explode: false
        },
        mode: {
            description: `routing profile to use (currently supported: \`WALK\`, \`BIKE\`, \`CAR\`)
`,
            '$ref': '#/components/schemas/Mode'
        },
        max: {
            description: 'maximum travel time in seconds. Is limited by server config variable `street_routing_max_direct_seconds`.',
            type: 'number'
        },
        maxMatchingDistance: {
            description: 'maximum matching distance in meters to match geo coordinates to the street network',
            type: 'number'
        },
        elevationCosts: {
            description: `Optional. Default is \`NONE\`.

Set an elevation cost profile, to penalize routes with incline.
- \`NONE\`: No additional costs for elevations. This is the default behavior
- \`LOW\`: Add a low cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if small detours are required.
- \`HIGH\`: Add a high cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if larger detours are required.

As using an elevation costs profile will increase the travel duration,
routing through steep terrain may exceed the maximal allowed duration,
causing a location to appear unreachable.
Increasing the maximum travel time for these segments may resolve this issue.

Elevation cost profiles are currently used by following street modes:
- \`BIKE\`
`,
            '$ref': '#/components/schemas/ElevationCosts',
            default: 'NONE'
        },
        arriveBy: {
            description: `true = many to one
false = one to many
`,
            type: 'boolean'
        },
        withDistance: {
            description: `If true, the response includes the distance in meters
for each path. This requires path reconstruction and
may be slower than duration-only queries.
`,
            type: 'boolean'
        }
    }
} as const;

export const ServerConfigSchema = {
    Description: 'server configuration',
    type: 'object',
    required: ['hasElevation', 'hasRoutedTransfers', 'hasStreetRouting', 'maxOneToManySize', 'maxOneToAllTravelTimeLimit', 'maxPrePostTransitTimeLimit', 'maxDirectTimeLimit'],
    properties: {
        hasElevation: {
            description: 'true if elevation is loaded',
            type: 'boolean'
        },
        hasRoutedTransfers: {
            description: 'true if routed transfers available',
            type: 'boolean'
        },
        hasStreetRouting: {
            description: 'true if street routing is available',
            type: 'boolean'
        },
        maxOneToManySize: {
            description: `limit for the number of \`many\` locations for one-to-many requests
`,
            type: 'number'
        },
        maxOneToAllTravelTimeLimit: {
            description: 'limit for maxTravelTime API param in minutes',
            type: 'number'
        },
        maxPrePostTransitTimeLimit: {
            description: 'limit for maxPrePostTransitTime API param in seconds',
            type: 'number'
        },
        maxDirectTimeLimit: {
            description: 'limit for maxDirectTime API param in seconds',
            type: 'number'
        }
    }
} as const;

export const ErrorSchema = {
    type: 'object',
    required: ['error'],
    properties: {
        error: {
            type: 'string',
            description: 'error message'
        }
    }
} as const;

export const RouteSegmentSchema = {
    description: 'Route segment between two stops to show a route on a map',
    type: 'object',
    required: ['from', 'to', 'polyline'],
    properties: {
        from: {
            '$ref': '#/components/schemas/Place'
        },
        to: {
            '$ref': '#/components/schemas/Place'
        },
        polyline: {
            '$ref': '#/components/schemas/EncodedPolyline'
        }
    }
} as const;

export const RouteColorSchema = {
    type: 'object',
    required: ['color', 'textColor'],
    properties: {
        color: {
            type: 'string'
        },
        textColor: {
            type: 'string'
        }
    }
} as const;

export const RoutePathSourceSchema = {
    type: 'string',
    enum: ['NONE', 'TIMETABLE', 'ROUTED']
} as const;

export const TransitRouteInfoSchema = {
    type: 'object',
    required: ['id', 'shortName', 'longName'],
    properties: {
        id: {
            type: 'string'
        },
        shortName: {
            type: 'string'
        },
        longName: {
            type: 'string'
        },
        color: {
            type: 'string'
        },
        textColor: {
            type: 'string'
        }
    }
} as const;

export const RouteInfoSchema = {
    type: 'object',
    required: ['mode', 'transitRoutes', 'numStops', 'routeIdx', 'pathSource', 'segments'],
    properties: {
        mode: {
            '$ref': '#/components/schemas/Mode',
            description: 'Transport mode for this route'
        },
        transitRoutes: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/TransitRouteInfo'
            }
        },
        numStops: {
            type: 'integer',
            description: 'Number of stops along this route'
        },
        routeIdx: {
            type: 'integer',
            description: 'Internal route index for debugging purposes'
        },
        pathSource: {
            '$ref': '#/components/schemas/RoutePathSource'
        },
        segments: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/RouteSegment'
            }
        }
    }
} as const;