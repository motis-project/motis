// This file is auto-generated by @hey-api/openapi-ts

/**
 * Object containing duration if a path was found or none if no path was found
 */
export type Duration = {
    /**
     * duration in seconds if a path was found, otherwise missing
     */
    duration?: number;
};

/**
 * Administrative area
 */
export type Area = {
    /**
     * Name of the area
     */
    name: string;
    /**
     * [OpenStreetMap `admin_level`](https://wiki.openstreetmap.org/wiki/Key:admin_level)
     * of the area
     *
     */
    adminLevel: number;
    /**
     * Whether this area was matched by the input text
     */
    matched: boolean;
    /**
     * Whether this area should be displayed as default area (area with admin level closest 7)
     */
    default?: boolean;
};

/**
 * Matched token range (from index, length)
 */
export type Token = [
    number,
    number
];

/**
 * GeoCoding match
 */
export type Match = {
    /**
     * location type
     */
    type: 'ADDRESS' | 'PLACE' | 'STOP';
    /**
     * list of non-overlapping tokens that were matched
     */
    tokens: Array<Token>;
    /**
     * name of the location (transit stop / PoI / address)
     */
    name: string;
    /**
     * unique ID of the location
     */
    id: string;
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    /**
     * level according to OpenStreetMap
     * (at the moment only for public transport)
     *
     */
    level?: number;
    /**
     * street name
     */
    street?: string;
    /**
     * house number
     */
    houseNumber?: string;
    /**
     * zip code
     */
    zip?: string;
    /**
     * list of areas
     */
    areas: Array<Area>;
    /**
     * score according to the internal scoring system (the scoring algorithm might change in the future)
     */
    score: number;
};

/**
 * location type
 */
export type type = 'ADDRESS' | 'PLACE' | 'STOP';

/**
 * # Street modes
 *
 * - `WALK`: Walking some or all of the way of the route.
 * - `BIKE`: Cycling for the entirety of the route or taking a bicycle onto the public transport (if enabled) and cycling from the arrival station to the destination.
 * - `BIKE_RENTAL`: Taking a rented, shared-mobility bike for part or the entirety of the route.
 * - `BIKE_TO_PARK`: Leaving the bicycle at the departure station and walking from the arrival station to the destination. This mode needs to be combined with at least one transit mode otherwise it behaves like an ordinary bicycle journey.
 * - `CAR`: Driving your own car the entirety of the route. This can be combined with transit, where will return routes with a Kiss & Ride component. This means that the car is not parked in a permanent parking area but rather the passenger is dropped off (for example, at an airport) and the driver continues driving the car away from the drop off location.
 * - `CAR_PARK` | `CAR_TO_PARK`: Driving a car to the park-and-ride facilities near a station and taking publictransport. This mode needs to be combined with at least one transit mode otherwise, it behaves like an ordinary car journey.
 * - `CAR_HAILING`: Using a car hailing app like Uber or Lyft to get to a train station or all the way to the destination.
 * - `CAR_PICKUP`: Walking to a pickup point along the road, driving to a drop-off point along the road, and walking the rest of the way. This can include various taxi-services or kiss & ride.
 * - `CAR_RENTAL`: Walk to a car rental point, drive to a car rental drop-off point and walk the rest of the way. This can include car rental at fixed locations or free-floating services.
 * - `FLEXIBLE`: Encompasses all types of on-demand and flexible transportation for example GTFS Flex or NeTEx Flexible Stop Places.
 * - `SCOOTER_RENTAL`: Walking to a scooter rental point, riding a scooter to a scooter rental drop-off point, and walking the rest of the way. This can include scooter rental at fixed locations or free-floating services.
 *
 * # Transit modes
 *
 * - `TRANSIT`: translates to `RAIL,SUBWAY,TRAM,BUS,FERRY,AIRPLANE,COACH`
 * - `TRAM`: trams
 * - `SUBWAY`: subway trains
 * - `FERRY`: ferries
 * - `AIRPLANE`: airline flights
 * - `BUS`: short distance buses (does not include `COACH`)
 * - `COACH`: long distance buses (does not include `BUS`)
 * - `RAIL`: translates to `HIGHSPEED_RAIL,LONG_DISTANCE_RAIL,NIGHT_RAIL,REGIONAL_RAIL,REGIONAL_FAST_RAIL`
 * - `METRO`: metro trains
 * - `HIGHSPEED_RAIL`: long distance high speed trains (e.g. TGV)
 * - `LONG_DISTANCE`: long distance inter city trains
 * - `NIGHT_RAIL`: long distance night trains
 * - `REGIONAL_FAST_RAIL`: regional express routes that skip low traffic stops to be faster
 * - `REGIONAL_RAIL`: regional train
 *
 */
export type Mode = 'WALK' | 'BIKE' | 'CAR' | 'BIKE_RENTAL' | 'BIKE_TO_PARK' | 'CAR_TO_PARK' | 'CAR_HAILING' | 'CAR_SHARING' | 'CAR_PICKUP' | 'CAR_RENTAL' | 'FLEXIBLE' | 'SCOOTER_RENTAL' | 'TRANSIT' | 'TRAM' | 'SUBWAY' | 'FERRY' | 'AIRPLANE' | 'METRO' | 'BUS' | 'COACH' | 'RAIL' | 'HIGHSPEED_RAIL' | 'LONG_DISTANCE' | 'NIGHT_RAIL' | 'REGIONAL_FAST_RAIL' | 'REGIONAL_RAIL' | 'OTHER';

/**
 * - `NORMAL` - latitude / longitude coordinate or address
 * - `BIKESHARE` - bike sharing station
 * - `BIKEPARK` - bike parking
 * - `TRANSIT` - transit stop
 *
 */
export type VertexType = 'NORMAL' | 'BIKESHARE' | 'BIKEPARK' | 'TRANSIT';

export type Place = {
    /**
     * name of the transit stop / PoI / address
     */
    name: string;
    /**
     * The ID of the stop. This is often something that users don't care about.
     */
    stopId?: string;
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    /**
     * level according to OpenStreetMap
     */
    level: number;
    /**
     * The offset from the scheduled arrival time of the boarding stop in this leg (in milliseconds).
     * Scheduled time of arrival at boarding stop = endTime - arrivalDelay
     *
     */
    arrivalDelay?: number;
    /**
     * The offset from the scheduled departure time of the boarding stop in this leg (in milliseconds).
     * Scheduled time of departure at boarding stop = startTime - departureDelay
     *
     */
    departureDelay?: number;
    /**
     * arrival time
     */
    arrival?: string;
    /**
     * departure time
     */
    departure?: string;
    /**
     * scheduled track from the static schedule timetable dataset
     */
    scheduledTrack?: string;
    /**
     * The current track/platform information, updated with real-time updates if available.
     * Can be missing if neither real-time updates nor the schedule timetable contains track information.
     *
     */
    track?: string;
    vertexType?: VertexType;
};

/**
 * departure or arrival event at a stop
 */
export type StopTime = {
    /**
     * information about the stop place and time
     */
    place: Place;
    /**
     * Transport mode for this leg
     */
    mode: Mode;
    /**
     * Whether there is real-time data about this leg
     */
    realTime: boolean;
    /**
     * For transit legs, the headsign of the bus or train being used.
     * For non-transit legs, null
     *
     */
    headsign: string;
    agencyId: string;
    agencyName: string;
    agencyUrl: string;
    routeColor?: string;
    routeTextColor?: string;
    tripId: string;
    routeShortName: string;
    /**
     * Filename and line number where this trip is from
     */
    source: string;
};

/**
 * trip id and name
 */
export type TripInfo = {
    /**
     * trip ID (dataset trip id prefixed with the dataset tag)
     */
    tripId: string;
    /**
     * trip display name
     */
    routeShortName: string;
};

/**
 * trip segment between two stops to show a trip on a map
 */
export type TripSegment = {
    trips: Array<TripInfo>;
    routeColor?: string;
    /**
     * Transport mode for this leg
     */
    mode: Mode;
    /**
     * distance in meters
     */
    distance: number;
    from: Place;
    to: Place;
    /**
     * departure time
     */
    departure: string;
    /**
     * arrival time
     */
    arrival: string;
    /**
     * The offset from the scheduled departure time of the boarding stop in this leg (in milliseconds).
     * Scheduled time of departure at boarding stop = startTime - departureDelay
     *
     */
    departureDelay: number;
    /**
     * The offset from the scheduled arrival time of the boarding stop in this leg (in milliseconds).
     * Scheduled time of arrival at boarding stop = endTime - arrivalDelay
     *
     */
    arrivalDelay: number;
    /**
     * Whether there is real-time data about this leg
     */
    realTime: boolean;
    /**
     * Google polyline encoded coordinate sequence (with precision 7) where the trip travels on this segment.
     */
    polyline: string;
};

export type RelativeDirection = 'DEPART' | 'HARD_LEFT' | 'LEFT' | 'SLIGHTLY_LEFT' | 'CONTINUE' | 'SLIGHTLY_RIGHT' | 'RIGHT' | 'HARD_RIGHT' | 'CIRCLE_CLOCKWISE' | 'CIRCLE_COUNTERCLOCKWISE' | 'ELEVATOR' | 'UTURN_LEFT' | 'UTURN_RIGHT';

export type AbsoluteDirection = 'NORTH' | 'NORTHEAST' | 'EAST' | 'SOUTHEAST' | 'SOUTH' | 'SOUTHWEST' | 'WEST' | 'NORTHWEST';

export type EncodedPolyline = {
    /**
     * The encoded points of the polyline using the Google polyline encoding with precision 7.
     */
    points: string;
    /**
     * The number of points in the string
     */
    length: number;
};

export type StepInstruction = {
    relativeDirection: RelativeDirection;
    absoluteDirection: AbsoluteDirection;
    /**
     * The distance in meters that this step takes.
     */
    distance: number;
    /**
     * level where this segment starts, based on OpenStreetMap data
     */
    fromLevel: number;
    /**
     * level where this segment starts, based on OpenStreetMap data
     */
    toLevel: number;
    /**
     * OpenStreetMap way index
     */
    osmWay?: number;
    polyline: EncodedPolyline;
    /**
     * The name of the street.
     */
    streetName: string;
    /**
     * Not implemented!
     * When exiting a highway or traffic circle, the exit name/number.
     *
     */
    exit: string;
    /**
     * Not implemented!
     * Indicates whether or not a street changes direction at an intersection.
     *
     */
    stayOn: boolean;
    /**
     * Not implemented!
     * This step is on an open area, such as a plaza or train platform,
     * and thus the directions should say something like "cross"
     *
     */
    area: boolean;
};

/**
 * Vehicle rental
 */
export type Rental = {
    /**
     * Vehicle share system ID
     */
    systemId: string;
    /**
     * Vehicle share system name
     */
    systemName?: string;
    /**
     * URL of the vehicle share system
     */
    url?: string;
    /**
     * Name of the station
     */
    stationName?: string;
    /**
     * Rental URI for Android (deep link to the specific station or vehicle)
     */
    rentalUriAndroid?: string;
    /**
     * Rental URI for iOS (deep link to the specific station or vehicle)
     */
    rentalUriIOS?: string;
    /**
     * Rental URI for web (deep link to the specific station or vehicle)
     */
    rentalUriWeb?: string;
};

export type Leg = {
    /**
     * Transport mode for this leg
     */
    mode: Mode;
    from: Place;
    to: Place;
    /**
     * Leg duration in seconds
     */
    duration: number;
    /**
     * leg departure time
     */
    startTime: string;
    /**
     * leg arrival time
     */
    endTime: string;
    /**
     * The offset from the scheduled departure time of the boarding stop in this leg (in milliseconds).
     * Scheduled time of departure at boarding stop = startTime - departureDelay
     *
     */
    departureDelay: number;
    /**
     * The offset from the scheduled arrival time of the boarding stop in this leg (in milliseconds).
     * Scheduled time of arrival at boarding stop = endTime - arrivalDelay
     *
     */
    arrivalDelay: number;
    /**
     * Whether there is real-time data about this leg
     */
    realTime: boolean;
    /**
     * The distance traveled while traversing this leg in meters.
     */
    distance: number;
    /**
     * For transit legs, if the rider should stay on the vehicle as it changes route names.
     */
    interlineWithPreviousLeg?: boolean;
    /**
     * For transit legs, the route of the bus or train being used.
     * For non-transit legs, the name of the street being traversed.
     *
     */
    route?: string;
    /**
     * For transit legs, the headsign of the bus or train being used.
     * For non-transit legs, null
     *
     */
    headsign?: string;
    agencyName?: string;
    agencyUrl?: string;
    routeColor?: string;
    routeTextColor?: string;
    routeType?: string;
    routeId?: string;
    agencyId?: string;
    tripId?: string;
    routeShortName?: string;
    /**
     * Filename and line number where this trip is from
     */
    source?: string;
    /**
     * For transit legs, intermediate stops between the Place where the leg originates
     * and the Place where the leg ends. For non-transit legs, null.
     *
     */
    intermediateStops?: Array<Place>;
    legGeometry: EncodedPolyline;
    /**
     * A series of turn by turn instructions
     * used for walking, biking and driving.
     *
     */
    steps?: Array<StepInstruction>;
    rental?: Rental;
};

export type Itinerary = {
    /**
     * journey duration in seconds
     */
    duration: number;
    /**
     * journey departure time
     */
    startTime: string;
    /**
     * journey arrival time
     */
    endTime: string;
    /**
     * The number of transfers this trip has.
     */
    transfers: number;
    /**
     * Journey legs
     */
    legs: Array<Leg>;
};

/**
 * footpath from one location to another
 */
export type Footpath = {
    to: Place;
    /**
     * optional; missing if the GTFS did not contain a footpath
     * footpath duration in minutes according to GTFS (+heuristics)
     *
     */
    default?: number;
    /**
     * optional; missing if no path was found with the foot profile
     * footpath duration in minutes for the foot profile
     *
     */
    foot?: number;
    /**
     * optional; missing if no path was found with the wheelchair profile
     * footpath duration in minutes for the wheelchair profile
     *
     */
    wheelchair?: number;
    /**
     * optional; missing if no path was found with the wheelchair profile
     * true if the wheelchair path uses an elevator
     *
     */
    wheelchairUsesElevator?: boolean;
};

export type OneToManyData = {
    query: {
        /**
         * true = many to one
         * false = one to many
         *
         */
        arriveBy: boolean;
        /**
         * geo locations as latitude;longitude,latitude;longitude,...
         */
        many: Array<(string)>;
        /**
         * maximum travel time in seconds
         */
        max: number;
        /**
         * maximum matching distance in meters to match geo coordinates to the street network
         */
        maxMatchingDistance: number;
        /**
         * routing profile to use (currently supported: \`WALK\`, \`BIKE\`, \`CAR\`)
         *
         */
        mode: Mode;
        /**
         * geo location as latitude,longitude
         */
        one: string;
    };
};

export type OneToManyResponse = (Array<Duration>);

export type OneToManyError = unknown;

export type ReverseGeocodeData = {
    query: {
        /**
         * latitude, longitude in degrees
         */
        place: string;
    };
};

export type ReverseGeocodeResponse = (Array<Match>);

export type ReverseGeocodeError = unknown;

export type GeocodeData = {
    query: {
        /**
         * language tags as used in OpenStreetMap
         * (usually ISO 639-1, or ISO 639-2 if there's no ISO 639-1)
         *
         */
        language?: string;
        /**
         * the (potentially partially typed) address to resolve
         */
        text: string;
    };
};

export type GeocodeResponse = (Array<Match>);

export type GeocodeError = unknown;

export type TripData = {
    query: {
        /**
         * trip identifier (e.g. from an itinerary leg or stop event)
         */
        tripId: string;
    };
};

export type TripResponse = (Itinerary);

export type TripError = unknown;

export type StoptimesData = {
    query: {
        /**
         * Optional. Default is `false`.
         *
         * - `arriveBy=true`: the parameters `date` and `time` refer to the arrival time
         * - `arriveBy=false`: the parameters `date` and `time` refer to the departure time
         *
         */
        arriveBy?: boolean;
        /**
         * the number of events
         */
        n: number;
        /**
         * Use the cursor to go to the next "page" of stop times.
         * Copy the cursor from the last response and keep the original request as is.
         * This will enable you to search for stop times in the next or previous time-window.
         *
         */
        pageCursor?: string;
        /**
         * Optional. Radius in meters.
         *
         * Default is that only stop times of the parent of the stop itself
         * and all stops with the same name (+ their child stops) are returned.
         *
         * If set, all stops at parent stations and their child stops in the specified radius
         * are returned.
         *
         */
        radius?: number;
        /**
         * stop id of the stop to retrieve departures/arrivals for
         */
        stopId: string;
        /**
         * Optional. Defaults to the current time.
         *
         */
        time?: string;
    };
};

export type StoptimesResponse = ({
    /**
     * list of stop times
     */
    stopTimes: Array<StopTime>;
    /**
     * Use the cursor to get the previous page of results. Insert the cursor into the request and post it to get the previous page.
     * The previous page is a set of stop times BEFORE the first stop time in the result.
     *
     */
    previousPageCursor: string;
    /**
     * Use the cursor to get the next page of results. Insert the cursor into the request and post it to get the next page.
     * The next page is a set of stop times AFTER the last stop time in this result.
     *
     */
    nextPageCursor: string;
});

export type StoptimesError = unknown;

export type PlanData = {
    query: {
        /**
         * Optional. Default is `false`.
         *
         * - `arriveBy=true`: the parameters `date` and `time` refer to the arrival time
         * - `arriveBy=false`: the parameters `date` and `time` refer to the departure time
         *
         */
        arriveBy?: boolean;
        /**
         * \`latitude,longitude,level\` tuple in degrees OR stop id
         */
        fromPlace: string;
        /**
         * The maximum travel time in hours.
         * If not provided, the routing to uses the value
         * hardcoded in the server which is usually quite high.
         *
         * *Warning*: Use with care. Setting this too low can lead to
         * optimal (e.g. the least transfers) journeys not being found.
         * If this value is too low to reach the destination at all,
         * it can lead to slow routing performance.
         *
         */
        maxHours?: number;
        /**
         * Optional. Default is 15min which is `900`.
         * Maximum time in seconds for the last street leg.
         *
         */
        maxPostTransitTime?: number;
        /**
         * Optional. Default is 15min which is `900`.
         * Maximum time in seconds for the first street leg.
         *
         */
        maxPreTransitTime?: number;
        /**
         * The maximum number of allowed transfers.
         * If not provided, the routing uses the server-side default value
         * which is hardcoded and very high to cover all use cases.
         *
         * *Warning*: Use with care. Setting this too low can lead to
         * optimal (e.g. the fastest) journeys not being found.
         * If this value is too low to reach the destination at all,
         * it can lead to slow routing performance.
         *
         */
        maxTransfers?: number;
        /**
         * Minimum transfer time for each transfer.
         */
        minTransferTime?: number;
        /**
         * A comma separated list of allowed modes.
         *
         * Default if not provided: `WALK,TRANSIT`
         *
         */
        mode?: Array<Mode>;
        /**
         * The minimum number of itineraries to compute.
         * This is only relevant if `timetableView=true`.
         * The default value is 5.
         *
         */
        numItineraries?: number;
        /**
         * Use the cursor to go to the next "page" of itineraries.
         * Copy the cursor from the last response and keep the original request as is.
         * This will enable you to search for itineraries in the next or previous time-window.
         *
         */
        pageCursor?: string;
        /**
         * Optional. Default is 2 hours which is `7200`.
         *
         * The length of the search-window in seconds. Default value two hours.
         *
         * - `arriveBy=true`: number of seconds between the earliest departure time and latest departure time
         * - `arriveBy=false`: number of seconds between the earliest arrival time and the latest arrival time
         *
         */
        searchWindow?: number;
        /**
         * Optional. Defaults to the current time.
         *
         * Departure time ($arriveBy=false) / arrival date ($arriveBy=true),
         *
         */
        time?: string;
        /**
         * Optional. Default is `true`.
         *
         * Search for the best trip options within a time window.
         * If true two itineraries are considered optimal
         * if one is better on arrival time (earliest wins)
         * and the other is better on departure time (latest wins).
         * In combination with arriveBy this parameter cover the following use cases:
         *
         * `timetable=false` = waiting for the first transit departure/arrival is considered travel time:
         * - `arriveBy=true`: event (e.g. a meeting) starts at 10:00 am,
         * compute the best journeys that arrive by that time (maximizes departure time)
         * - `arriveBy=false`: event (e.g. a meeting) ends at 11:00 am,
         * compute the best journeys that depart after that time
         *
         * `timetable=true` = optimize "later departure" + "earlier arrival" and give all options over a time window:
         * - `arriveBy=true`: the time window around `date` and `time` refers to the arrival time window
         * - `arriveBy=false`: the time window around `date` and `time` refers to the departure time window
         *
         */
        timetableView?: boolean;
        /**
         * \`latitude,longitude,level\` tuple in degrees OR stop id
         */
        toPlace: string;
        /**
         * Factor to multiply transfer times with.
         */
        transferTimeFactor?: number;
        /**
         * Whether the trip must be wheelchair accessible.
         */
        wheelchair?: boolean;
    };
};

export type PlanResponse = ({
    /**
     * the routing query
     */
    requestParameters: {
        [key: string]: (string);
    };
    /**
     * debug statistics
     */
    debugOutput: {
        [key: string]: (string);
    };
    from: Place;
    to: Place;
    /**
     * Direct trips by `WALK`, `BIKE`, `CAR`, etc. without time-dependency.
     * The starting time (`arriveBy=false`) / arrival time (`arriveBy=true`) is always the queried `time` parameter (set to \"now\" if not set).
     * But all `direct` connections are meant to be independent of absolute times.
     *
     */
    direct: Array<Itinerary>;
    /**
     * list of itineraries
     */
    itineraries: Array<Itinerary>;
    /**
     * Use the cursor to get the previous page of results. Insert the cursor into the request and post it to get the previous page.
     * The previous page is a set of itineraries departing BEFORE the first itinerary in the result for a depart after search. When using the default sort order the previous set of itineraries is inserted before the current result.
     *
     */
    previousPageCursor: string;
    /**
     * Use the cursor to get the next page of results. Insert the cursor into the request and post it to get the next page.
     * The next page is a set of itineraries departing AFTER the last itinerary in this result.
     *
     */
    nextPageCursor: string;
});

export type PlanError = unknown;

export type TripsData = {
    query: {
        /**
         * end if the time window
         */
        endTime: string;
        /**
         * latitude,longitude pair of the upper left coordinate
         */
        max: string;
        /**
         * latitude,longitude pair of the lower right coordinate
         */
        min: string;
        /**
         * start of the time window
         */
        startTime: string;
        /**
         * current zoom level
         */
        zoom: number;
    };
};

export type TripsResponse = (Array<TripSegment>);

export type TripsError = unknown;

export type InitialResponse = ({
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    /**
     * zoom level
     */
    zoom: number;
});

export type InitialError = unknown;

export type StopsData = {
    query: {
        /**
         * latitude,longitude pair of the upper left coordinate
         */
        max: string;
        /**
         * latitude,longitude pair of the lower right coordinate
         */
        min: string;
    };
};

export type StopsResponse = (Array<Place>);

export type StopsError = unknown;

export type LevelsData = {
    query: {
        /**
         * latitude,longitude pair of the upper left coordinate
         */
        max: string;
        /**
         * latitude,longitude pair of the lower right coordinate
         */
        min: string;
    };
};

export type LevelsResponse = (Array<(number)>);

export type LevelsError = unknown;

export type FootpathsData = {
    query: {
        /**
         * location id
         */
        id: string;
    };
};

export type FootpathsResponse = ({
    place: Place;
    /**
     * all outgoing footpaths of this location
     */
    footpaths: Array<Footpath>;
});

export type FootpathsError = unknown;