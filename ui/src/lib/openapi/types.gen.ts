// This file is auto-generated by @hey-api/openapi-ts

/**
 * Object containing duration if a path was found or none if no path was found
 */
export type Duration = {
    /**
     * duration in seconds if a path was found, otherwise missing
     */
    duration?: number;
};

/**
 * Administrative area
 */
export type Area = {
    /**
     * Name of the area
     */
    name: string;
    /**
     * [OpenStreetMap `admin_level`](https://wiki.openstreetmap.org/wiki/Key:admin_level)
     * of the area
     *
     */
    adminLevel: number;
    /**
     * Whether this area was matched by the input text
     */
    matched: boolean;
    /**
     * Whether this area should be displayed as default area (area with admin level closest 7)
     */
    default?: boolean;
};

/**
 * Matched token range (from index, length)
 */
export type Token = [
    number,
    number
];

/**
 * GeoCoding match
 */
export type Match = {
    /**
     * location type
     */
    type: 'ADDRESS' | 'PLACE' | 'STOP';
    /**
     * list of non-overlapping tokens that were matched
     */
    tokens: Array<Token>;
    /**
     * name of the location (transit stop / PoI / address)
     */
    name: string;
    /**
     * unique ID of the location
     */
    id: string;
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    /**
     * level according to OpenStreetMap
     * (at the moment only for public transport)
     *
     */
    level?: number;
    /**
     * street name
     */
    street?: string;
    /**
     * house number
     */
    houseNumber?: string;
    /**
     * zip code
     */
    zip?: string;
    /**
     * list of areas
     */
    areas: Array<Area>;
    /**
     * score according to the internal scoring system (the scoring algorithm might change in the future)
     */
    score: number;
};

/**
 * location type
 */
export type type = 'ADDRESS' | 'PLACE' | 'STOP';

/**
 * # Street modes
 *
 * - `WALK`
 * - `BIKE`
 * - `BIKE_RENTAL`
 * - `CAR`
 * - `CAR_PARKING`
 *
 * # Transit modes
 *
 * - `TRANSIT`: translates to `RAIL,SUBWAY,TRAM,BUS,FERRY,AIRPLANE,COACH`
 * - `TRAM`: trams
 * - `SUBWAY`: subway trains
 * - `FERRY`: ferries
 * - `AIRPLANE`: airline flights
 * - `BUS`: short distance buses (does not include `COACH`)
 * - `COACH`: long distance buses (does not include `BUS`)
 * - `RAIL`: translates to `HIGHSPEED_RAIL,LONG_DISTANCE_RAIL,NIGHT_RAIL,REGIONAL_RAIL,REGIONAL_FAST_RAIL`
 * - `METRO`: metro trains
 * - `HIGHSPEED_RAIL`: long distance high speed trains (e.g. TGV)
 * - `LONG_DISTANCE`: long distance inter city trains
 * - `NIGHT_RAIL`: long distance night trains
 * - `REGIONAL_FAST_RAIL`: regional express routes that skip low traffic stops to be faster
 * - `REGIONAL_RAIL`: regional train
 *
 */
export type Mode = 'WALK' | 'BIKE' | 'CAR' | 'BIKE_RENTAL' | 'CAR_PARKING' | 'TRANSIT' | 'TRAM' | 'SUBWAY' | 'FERRY' | 'AIRPLANE' | 'METRO' | 'BUS' | 'COACH' | 'RAIL' | 'HIGHSPEED_RAIL' | 'LONG_DISTANCE' | 'NIGHT_RAIL' | 'REGIONAL_FAST_RAIL' | 'REGIONAL_RAIL' | 'OTHER';

/**
 * - `NORMAL` - latitude / longitude coordinate or address
 * - `BIKESHARE` - bike sharing station
 * - `TRANSIT` - transit stop
 *
 */
export type VertexType = 'NORMAL' | 'BIKESHARE' | 'TRANSIT';

export type Place = {
    /**
     * name of the transit stop / PoI / address
     */
    name: string;
    /**
     * The ID of the stop. This is often something that users don't care about.
     */
    stopId?: string;
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    /**
     * level according to OpenStreetMap
     */
    level: number;
    /**
     * arrival time
     */
    arrival?: string;
    /**
     * departure time
     */
    departure?: string;
    /**
     * scheduled arrival time
     */
    scheduledArrival?: string;
    /**
     * scheduled departure time
     */
    scheduledDeparture?: string;
    /**
     * scheduled track from the static schedule timetable dataset
     */
    scheduledTrack?: string;
    /**
     * The current track/platform information, updated with real-time updates if available.
     * Can be missing if neither real-time updates nor the schedule timetable contains track information.
     *
     */
    track?: string;
    vertexType?: VertexType;
};

/**
 * departure or arrival event at a stop
 */
export type StopTime = {
    /**
     * information about the stop place and time
     */
    place: Place;
    /**
     * Transport mode for this leg
     */
    mode: Mode;
    /**
     * Whether there is real-time data about this leg
     */
    realTime: boolean;
    /**
     * For transit legs, the headsign of the bus or train being used.
     * For non-transit legs, null
     *
     */
    headsign: string;
    agencyId: string;
    agencyName: string;
    agencyUrl: string;
    routeColor?: string;
    routeTextColor?: string;
    tripId: string;
    routeShortName: string;
    /**
     * Filename and line number where this trip is from
     */
    source: string;
};

/**
 * trip id and name
 */
export type TripInfo = {
    /**
     * trip ID (dataset trip id prefixed with the dataset tag)
     */
    tripId: string;
    /**
     * trip display name
     */
    routeShortName: string;
};

/**
 * trip segment between two stops to show a trip on a map
 */
export type TripSegment = {
    trips: Array<TripInfo>;
    routeColor?: string;
    /**
     * Transport mode for this leg
     */
    mode: Mode;
    /**
     * distance in meters
     */
    distance: number;
    from: Place;
    to: Place;
    /**
     * departure time
     */
    departure: string;
    /**
     * arrival time
     */
    arrival: string;
    /**
     * scheduled departure time
     */
    scheduledDeparture: string;
    /**
     * scheduled arrival time
     */
    scheduledArrival: string;
    /**
     * Whether there is real-time data about this leg
     */
    realTime: boolean;
    /**
     * Google polyline encoded coordinate sequence (with precision 7) where the trip travels on this segment.
     */
    polyline: string;
};

export type Direction = 'DEPART' | 'HARD_LEFT' | 'LEFT' | 'SLIGHTLY_LEFT' | 'CONTINUE' | 'SLIGHTLY_RIGHT' | 'RIGHT' | 'HARD_RIGHT' | 'CIRCLE_CLOCKWISE' | 'CIRCLE_COUNTERCLOCKWISE' | 'STAIRS' | 'ELEVATOR' | 'UTURN_LEFT' | 'UTURN_RIGHT';

export type EncodedPolyline = {
    /**
     * The encoded points of the polyline using the Google polyline encoding with precision 7.
     */
    points: string;
    /**
     * The number of points in the string
     */
    length: number;
};

export type StepInstruction = {
    relativeDirection: Direction;
    /**
     * The distance in meters that this step takes.
     */
    distance: number;
    /**
     * level where this segment starts, based on OpenStreetMap data
     */
    fromLevel: number;
    /**
     * level where this segment starts, based on OpenStreetMap data
     */
    toLevel: number;
    /**
     * OpenStreetMap way index
     */
    osmWay?: number;
    polyline: EncodedPolyline;
    /**
     * The name of the street.
     */
    streetName: string;
    /**
     * Not implemented!
     * When exiting a highway or traffic circle, the exit name/number.
     *
     */
    exit: string;
    /**
     * Not implemented!
     * Indicates whether or not a street changes direction at an intersection.
     *
     */
    stayOn: boolean;
    /**
     * Not implemented!
     * This step is on an open area, such as a plaza or train platform,
     * and thus the directions should say something like "cross"
     *
     */
    area: boolean;
};

/**
 * Vehicle rental
 */
export type Rental = {
    /**
     * Vehicle share system ID
     */
    systemId: string;
    /**
     * Vehicle share system name
     */
    systemName?: string;
    /**
     * URL of the vehicle share system
     */
    url?: string;
    /**
     * Name of the station
     */
    stationName?: string;
    /**
     * Rental URI for Android (deep link to the specific station or vehicle)
     */
    rentalUriAndroid?: string;
    /**
     * Rental URI for iOS (deep link to the specific station or vehicle)
     */
    rentalUriIOS?: string;
    /**
     * Rental URI for web (deep link to the specific station or vehicle)
     */
    rentalUriWeb?: string;
};

export type Leg = {
    /**
     * Transport mode for this leg
     */
    mode: Mode;
    from: Place;
    to: Place;
    /**
     * Leg duration in seconds
     *
     * If leg is footpath:
     * The footpath duration is derived from the default footpath
     * duration using the query parameters `transferTimeFactor` and
     * `additionalTransferTime` as follows:
     * `leg.duration = defaultDuration * transferTimeFactor + additionalTransferTime.`
     * In case the defaultDuration is needed, it can be calculated by
     * `defaultDuration = (leg.duration - additionalTransferTime) / transferTimeFactor`.
     * Note that the default values are `transferTimeFactor = 1` and
     * `additionalTransferTime = 0` in case they are not explicitly
     * provided in the query.
     *
     */
    duration: number;
    /**
     * leg departure time
     */
    startTime: string;
    /**
     * leg arrival time
     */
    endTime: string;
    /**
     * scheduled leg departure time
     */
    scheduledStartTime: string;
    /**
     * scheduled leg arrival time
     */
    scheduledEndTime: string;
    /**
     * Whether there is real-time data about this leg
     */
    realTime: boolean;
    /**
     * For non-transit legs the distance traveled while traversing this leg in meters.
     */
    distance?: number;
    /**
     * For transit legs, if the rider should stay on the vehicle as it changes route names.
     */
    interlineWithPreviousLeg?: boolean;
    /**
     * For transit legs, the headsign of the bus or train being used.
     * For non-transit legs, null
     *
     */
    headsign?: string;
    routeColor?: string;
    routeTextColor?: string;
    routeType?: string;
    agencyName?: string;
    agencyUrl?: string;
    agencyId?: string;
    tripId?: string;
    routeShortName?: string;
    /**
     * Filename and line number where this trip is from
     */
    source?: string;
    /**
     * For transit legs, intermediate stops between the Place where the leg originates
     * and the Place where the leg ends. For non-transit legs, null.
     *
     */
    intermediateStops?: Array<Place>;
    legGeometry: EncodedPolyline;
    /**
     * A series of turn by turn instructions
     * used for walking, biking and driving.
     *
     */
    steps?: Array<StepInstruction>;
    rental?: Rental;
};

export type Itinerary = {
    /**
     * journey duration in seconds
     */
    duration: number;
    /**
     * journey departure time
     */
    startTime: string;
    /**
     * journey arrival time
     */
    endTime: string;
    /**
     * The number of transfers this trip has.
     */
    transfers: number;
    /**
     * Journey legs
     */
    legs: Array<Leg>;
};

/**
 * footpath from one location to another
 */
export type Footpath = {
    to: Place;
    /**
     * optional; missing if the GTFS did not contain a footpath
     * footpath duration in minutes according to GTFS (+heuristics)
     *
     */
    default?: number;
    /**
     * optional; missing if no path was found with the foot profile
     * footpath duration in minutes for the foot profile
     *
     */
    foot?: number;
    /**
     * optional; missing if no path was found with the wheelchair profile
     * footpath duration in minutes for the wheelchair profile
     *
     */
    wheelchair?: number;
    /**
     * optional; missing if no path was found with the wheelchair profile
     * true if the wheelchair path uses an elevator
     *
     */
    wheelchairUsesElevator?: boolean;
};

export type OneToManyData = {
    query: {
        /**
         * true = many to one
         * false = one to many
         *
         */
        arriveBy: boolean;
        /**
         * geo locations as latitude;longitude,latitude;longitude,...
         */
        many: Array<(string)>;
        /**
         * maximum travel time in seconds
         */
        max: number;
        /**
         * maximum matching distance in meters to match geo coordinates to the street network
         */
        maxMatchingDistance: number;
        /**
         * routing profile to use (currently supported: \`WALK\`, \`BIKE\`, \`CAR\`)
         *
         */
        mode: Mode;
        /**
         * geo location as latitude,longitude
         */
        one: string;
    };
};

export type OneToManyResponse = (Array<Duration>);

export type OneToManyError = unknown;

export type ReverseGeocodeData = {
    query: {
        /**
         * latitude, longitude in degrees
         */
        place: string;
    };
};

export type ReverseGeocodeResponse = (Array<Match>);

export type ReverseGeocodeError = unknown;

export type GeocodeData = {
    query: {
        /**
         * language tags as used in OpenStreetMap
         * (usually ISO 639-1, or ISO 639-2 if there's no ISO 639-1)
         *
         */
        language?: string;
        /**
         * the (potentially partially typed) address to resolve
         */
        text: string;
    };
};

export type GeocodeResponse = (Array<Match>);

export type GeocodeError = unknown;

export type TripData = {
    query: {
        /**
         * trip identifier (e.g. from an itinerary leg or stop event)
         */
        tripId: string;
    };
};

export type TripResponse = (Itinerary);

export type TripError = unknown;

export type StoptimesData = {
    query: {
        /**
         * Optional. Default is `false`.
         *
         * - `arriveBy=true`: the parameters `date` and `time` refer to the arrival time
         * - `arriveBy=false`: the parameters `date` and `time` refer to the departure time
         *
         */
        arriveBy?: boolean;
        /**
         * This parameter will be ignored in case `pageCursor` is set.
         *
         * Optional. Default is
         * - `LATER` for `arriveBy=false`
         * - `EARLIER` for `arriveBy=true`
         *
         * The response will contain the next `n` arrivals / departures
         * in case `EARLIER` is selected and the previous `n`
         * arrivals / departures if `LATER` is selected.
         *
         */
        direction?: 'EARLIER' | 'LATER';
        /**
         * Optional. Default is all transit modes.
         *
         * Only return arrivals/departures of the given modes.
         *
         */
        mode?: Array<Mode>;
        /**
         * the number of events
         */
        n: number;
        /**
         * Use the cursor to go to the next "page" of stop times.
         * Copy the cursor from the last response and keep the original request as is.
         * This will enable you to search for stop times in the next or previous time-window.
         *
         */
        pageCursor?: string;
        /**
         * Optional. Radius in meters.
         *
         * Default is that only stop times of the parent of the stop itself
         * and all stops with the same name (+ their child stops) are returned.
         *
         * If set, all stops at parent stations and their child stops in the specified radius
         * are returned.
         *
         */
        radius?: number;
        /**
         * stop id of the stop to retrieve departures/arrivals for
         */
        stopId: string;
        /**
         * Optional. Defaults to the current time.
         *
         */
        time?: string;
    };
};

export type StoptimesResponse = ({
    /**
     * list of stop times
     */
    stopTimes: Array<StopTime>;
    /**
     * Use the cursor to get the previous page of results. Insert the cursor into the request and post it to get the previous page.
     * The previous page is a set of stop times BEFORE the first stop time in the result.
     *
     */
    previousPageCursor: string;
    /**
     * Use the cursor to get the next page of results. Insert the cursor into the request and post it to get the next page.
     * The next page is a set of stop times AFTER the last stop time in this result.
     *
     */
    nextPageCursor: string;
});

export type StoptimesError = unknown;

export type PlanData = {
    query: {
        /**
         * Optional. Default is 0 minutes.
         *
         * Additional transfer time reserved for each transfer in minutes.
         *
         */
        additionalTransferTime?: number;
        /**
         * Optional. Default is `false`.
         *
         * - `arriveBy=true`: the parameters `date` and `time` refer to the arrival time
         * - `arriveBy=false`: the parameters `date` and `time` refer to the departure time
         *
         */
        arriveBy?: boolean;
        /**
         * Optional. Default is `WALK` which will compute walking routes as direct connections.
         *
         * Modes used for direction connections from start to destination without using transit.
         * Results will be returned on the `direct` key.
         *
         * Note: Direct connections will only be returned on the first call. For paging calls, they can be omitted.
         *
         * Note: Transit connections that are slower than the fastest direct connection will not show up.
         * This is being used as a cut-off during transit routing to speed up the search.
         * To prevent this, it's possible to send two separate requests (one with only `transitModes` and one with only `directModes`).
         *
         * Only non-transit modes such as `WALK`, `BIKE`, `CAR`, `BIKE_SHARING`, etc. can be used.
         *
         */
        directModes?: Array<Mode>;
        /**
         * \`latitude,longitude,level\` tuple in degrees OR stop id
         */
        fromPlace: string;
        /**
         * Optional. Default is 30min which is `1800`.
         * Maximum time in seconds for direct connections.
         *
         */
        maxDirectTime?: number;
        /**
         * The maximum travel time in hours.
         * If not provided, the routing to uses the value
         * hardcoded in the server which is usually quite high.
         *
         * *Warning*: Use with care. Setting this too low can lead to
         * optimal (e.g. the least transfers) journeys not being found.
         * If this value is too low to reach the destination at all,
         * it can lead to slow routing performance.
         *
         * TODO: pass parameter to nigiri
         *
         */
        maxHours?: number;
        /**
         * Optional. Default is 15min which is `900`.
         * Maximum time in seconds for the last street leg.
         *
         */
        maxPostTransitTime?: number;
        /**
         * Optional. Default is 15min which is `900`.
         * Maximum time in seconds for the first street leg.
         *
         */
        maxPreTransitTime?: number;
        /**
         * The maximum number of allowed transfers.
         * If not provided, the routing uses the server-side default value
         * which is hardcoded and very high to cover all use cases.
         *
         * *Warning*: Use with care. Setting this too low can lead to
         * optimal (e.g. the fastest) journeys not being found.
         * If this value is too low to reach the destination at all,
         * it can lead to slow routing performance.
         *
         */
        maxTransfers?: number;
        /**
         * Optional. Default is 0 minutes.
         *
         * Minimum transfer time for each transfer in minutes.
         *
         */
        minTransferTime?: number;
        /**
         * The minimum number of itineraries to compute.
         * This is only relevant if `timetableView=true`.
         * The default value is 5.
         *
         */
        numItineraries?: number;
        /**
         * Use the cursor to go to the next "page" of itineraries.
         * Copy the cursor from the last response and keep the original request as is.
         * This will enable you to search for itineraries in the next or previous time-window.
         *
         */
        pageCursor?: string;
        /**
         * Optional. Default is `WALK`. Only applies if the `to` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directModes`).
         *
         * A list of modes that are allowed to be used from the last transit stop to the `to` coordinate. Example: `WALK,BIKE_SHARING`.
         *
         */
        postTransitModes?: Array<Mode>;
        /**
         * Optional. Default is `WALK`. Only applies if the `from` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directModes`).
         *
         * A list of modes that are allowed to be used from the `from` coordinate to the first transit stop. Example: `WALK,BIKE_SHARING`.
         *
         */
        preTransitModes?: Array<Mode>;
        /**
         * Optional. Default is `false`.
         *
         * If set to `true`, all used transit trips are required to allow bike carriage.
         *
         */
        requireBikeTransport?: boolean;
        /**
         * Optional. Default is 2 hours which is `7200`.
         *
         * The length of the search-window in seconds. Default value two hours.
         *
         * - `arriveBy=true`: number of seconds between the earliest departure time and latest departure time
         * - `arriveBy=false`: number of seconds between the earliest arrival time and the latest arrival time
         *
         */
        searchWindow?: number;
        /**
         * Optional. Defaults to the current time.
         *
         * Departure time ($arriveBy=false) / arrival date ($arriveBy=true),
         *
         */
        time?: string;
        /**
         * Optional. Default is `true`.
         *
         * Search for the best trip options within a time window.
         * If true two itineraries are considered optimal
         * if one is better on arrival time (earliest wins)
         * and the other is better on departure time (latest wins).
         * In combination with arriveBy this parameter cover the following use cases:
         *
         * `timetable=false` = waiting for the first transit departure/arrival is considered travel time:
         * - `arriveBy=true`: event (e.g. a meeting) starts at 10:00 am,
         * compute the best journeys that arrive by that time (maximizes departure time)
         * - `arriveBy=false`: event (e.g. a meeting) ends at 11:00 am,
         * compute the best journeys that depart after that time
         *
         * `timetable=true` = optimize "later departure" + "earlier arrival" and give all options over a time window:
         * - `arriveBy=true`: the time window around `date` and `time` refers to the arrival time window
         * - `arriveBy=false`: the time window around `date` and `time` refers to the departure time window
         *
         */
        timetableView?: boolean;
        /**
         * \`latitude,longitude,level\` tuple in degrees OR stop id
         */
        toPlace: string;
        /**
         * Optional. Default is 1.0
         *
         * Factor to multiply minimum required transfer times with.
         * Values smaller than 1.0 are not supported.
         *
         */
        transferTimeFactor?: number;
        /**
         * Optional. Default is `TRANSIT` which allows all transit modes (no restriction).
         * Allowed modes for the transit part. If empty, no transit connections will be computed.
         * For example, this can be used to allow only `METRO,SUBWAY,TRAM`.
         *
         */
        transitModes?: Array<Mode>;
        /**
         * List of via stops to visit (only stop IDs, no coordinates allowed for now).
         * Also see the optional parameter `viaMinimumStay` to set a set a minimum stay duration for each via stop.
         *
         */
        via?: Array<(string)>;
        /**
         * Optional. If not set, the default is `0,0` - no stay required.
         *
         * For each `via` stop a minimum stay duration in minutes.
         *
         * The value `0` signals that it's allowed to stay in the same trip.
         * This enables via stays without counting a transfer and can lead
         * to better connections with less transfers. Transfer connections can
         * still be found with `viaMinimumStay=0`.
         *
         */
        viaMinimumStay?: Array<(number)>;
        /**
         * Whether the trip must be wheelchair accessible.
         */
        wheelchair?: boolean;
    };
};

export type PlanResponse = ({
    /**
     * the routing query
     */
    requestParameters: {
        [key: string]: (string);
    };
    /**
     * debug statistics
     */
    debugOutput: {
        [key: string]: (number);
    };
    from: Place;
    to: Place;
    /**
     * Direct trips by `WALK`, `BIKE`, `CAR`, etc. without time-dependency.
     * The starting time (`arriveBy=false`) / arrival time (`arriveBy=true`) is always the queried `time` parameter (set to \"now\" if not set).
     * But all `direct` connections are meant to be independent of absolute times.
     *
     */
    direct: Array<Itinerary>;
    /**
     * list of itineraries
     */
    itineraries: Array<Itinerary>;
    /**
     * Use the cursor to get the previous page of results. Insert the cursor into the request and post it to get the previous page.
     * The previous page is a set of itineraries departing BEFORE the first itinerary in the result for a depart after search. When using the default sort order the previous set of itineraries is inserted before the current result.
     *
     */
    previousPageCursor: string;
    /**
     * Use the cursor to get the next page of results. Insert the cursor into the request and post it to get the next page.
     * The next page is a set of itineraries departing AFTER the last itinerary in this result.
     *
     */
    nextPageCursor: string;
});

export type PlanError = unknown;

export type TripsData = {
    query: {
        /**
         * end if the time window
         */
        endTime: string;
        /**
         * latitude,longitude pair of the upper left coordinate
         */
        max: string;
        /**
         * latitude,longitude pair of the lower right coordinate
         */
        min: string;
        /**
         * start of the time window
         */
        startTime: string;
        /**
         * current zoom level
         */
        zoom: number;
    };
};

export type TripsResponse = (Array<TripSegment>);

export type TripsError = unknown;

export type InitialResponse = ({
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    /**
     * zoom level
     */
    zoom: number;
});

export type InitialError = unknown;

export type StopsData = {
    query: {
        /**
         * latitude,longitude pair of the upper left coordinate
         */
        max: string;
        /**
         * latitude,longitude pair of the lower right coordinate
         */
        min: string;
    };
};

export type StopsResponse = (Array<Place>);

export type StopsError = unknown;

export type LevelsData = {
    query: {
        /**
         * latitude,longitude pair of the upper left coordinate
         */
        max: string;
        /**
         * latitude,longitude pair of the lower right coordinate
         */
        min: string;
    };
};

export type LevelsResponse = (Array<(number)>);

export type LevelsError = unknown;

export type FootpathsData = {
    query: {
        /**
         * location id
         */
        id: string;
    };
};

export type FootpathsResponse = ({
    place: Place;
    /**
     * all outgoing footpaths of this location
     */
    footpaths: Array<Footpath>;
});

export type FootpathsError = unknown;