// This file is auto-generated by @hey-api/openapi-ts

export const DurationSchema = {
    description: 'Object containing duration if a path was found or none if no path was found',
    type: 'object',
    properties: {
        duration: {
            type: 'number',
            description: 'duration in seconds if a path was found, otherwise missing'
        }
    }
} as const;

export const AreaSchema = {
    description: 'Administrative area',
    type: 'object',
    required: ['name', 'adminLevel', 'matched'],
    properties: {
        name: {
            type: 'string',
            description: 'Name of the area'
        },
        adminLevel: {
            type: 'number',
            description: `[OpenStreetMap \`admin_level\`](https://wiki.openstreetmap.org/wiki/Key:admin_level)
of the area
`
        },
        matched: {
            type: 'boolean',
            description: 'Whether this area was matched by the input text'
        },
        default: {
            type: 'boolean',
            description: 'Whether this area should be displayed as default area (area with admin level closest 7)'
        }
    }
} as const;

export const TokenSchema = {
    description: 'Matched token range (from index, length)',
    type: 'array',
    minItems: 2,
    maxItems: 2,
    items: {
        type: 'number'
    }
} as const;

export const MatchSchema = {
    description: 'GeoCoding match',
    type: 'object',
    required: ['type', 'name', 'id', 'lat', 'lon', 'tokens', 'areas', 'score'],
    properties: {
        type: {
            description: 'location type',
            type: 'string',
            enum: ['ADDRESS', 'PLACE', 'STOP']
        },
        tokens: {
            description: 'list of non-overlapping tokens that were matched',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Token'
            }
        },
        name: {
            description: 'name of the location (transit stop / PoI / address)',
            type: 'string'
        },
        id: {
            description: 'unique ID of the location',
            type: 'string'
        },
        lat: {
            description: 'latitude',
            type: 'number'
        },
        lon: {
            description: 'longitude',
            type: 'number'
        },
        level: {
            description: `level according to OpenStreetMap
(at the moment only for public transport)
`,
            type: 'number'
        },
        street: {
            description: 'street name',
            type: 'string'
        },
        houseNumber: {
            description: 'house number',
            type: 'string'
        },
        zip: {
            description: 'zip code',
            type: 'string'
        },
        areas: {
            description: 'list of areas',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Area'
            }
        },
        score: {
            description: 'score according to the internal scoring system (the scoring algorithm might change in the future)',
            type: 'number'
        }
    }
} as const;

export const PedestrianProfileSchema = {
    description: 'Different accessibility profiles for pedestrians.',
    type: 'string',
    enum: ['FOOT', 'WHEELCHAIR']
} as const;

export const ModeSchema = {
    description: `# Street modes

  - \`WALK\`
  - \`BIKE\`
  - \`RENTAL\` Experimental. Expect unannounced breaking changes (without version bumps).
  - \`CAR\`
  - \`CAR_PARKING\`
  - \`ODM\`

# Transit modes

  - \`TRANSIT\`: translates to \`RAIL,SUBWAY,TRAM,BUS,FERRY,AIRPLANE,COACH\`
  - \`TRAM\`: trams
  - \`SUBWAY\`: subway trains
  - \`FERRY\`: ferries
  - \`AIRPLANE\`: airline flights
  - \`BUS\`: short distance buses (does not include \`COACH\`)
  - \`COACH\`: long distance buses (does not include \`BUS\`)
  - \`RAIL\`: translates to \`HIGHSPEED_RAIL,LONG_DISTANCE_RAIL,NIGHT_RAIL,REGIONAL_RAIL,REGIONAL_FAST_RAIL\`
  - \`METRO\`: metro trains
  - \`HIGHSPEED_RAIL\`: long distance high speed trains (e.g. TGV)
  - \`LONG_DISTANCE\`: long distance inter city trains
  - \`NIGHT_RAIL\`: long distance night trains
  - \`REGIONAL_FAST_RAIL\`: regional express routes that skip low traffic stops to be faster
  - \`REGIONAL_RAIL\`: regional train
`,
    type: 'string',
    enum: ['WALK', 'BIKE', 'RENTAL', 'CAR', 'CAR_PARKING', 'ODM', 'TRANSIT', 'TRAM', 'SUBWAY', 'FERRY', 'AIRPLANE', 'METRO', 'BUS', 'COACH', 'RAIL', 'HIGHSPEED_RAIL', 'LONG_DISTANCE', 'NIGHT_RAIL', 'REGIONAL_FAST_RAIL', 'REGIONAL_RAIL', 'OTHER']
} as const;

export const VertexTypeSchema = {
    type: 'string',
    description: `- \`NORMAL\` - latitude / longitude coordinate or address
- \`BIKESHARE\` - bike sharing station
- \`TRANSIT\` - transit stop
`,
    enum: ['NORMAL', 'BIKESHARE', 'TRANSIT']
} as const;

export const PlaceSchema = {
    type: 'object',
    required: ['name', 'lat', 'lon', 'level'],
    properties: {
        name: {
            description: 'name of the transit stop / PoI / address',
            type: 'string'
        },
        stopId: {
            description: "The ID of the stop. This is often something that users don't care about.",
            type: 'string'
        },
        lat: {
            description: 'latitude',
            type: 'number'
        },
        lon: {
            description: 'longitude',
            type: 'number'
        },
        level: {
            description: 'level according to OpenStreetMap',
            type: 'number'
        },
        arrival: {
            description: 'arrival time',
            type: 'string',
            format: 'date-time'
        },
        departure: {
            description: 'departure time',
            type: 'string',
            format: 'date-time'
        },
        scheduledArrival: {
            description: 'scheduled arrival time',
            type: 'string',
            format: 'date-time'
        },
        scheduledDeparture: {
            description: 'scheduled departure time',
            type: 'string',
            format: 'date-time'
        },
        scheduledTrack: {
            description: 'scheduled track from the static schedule timetable dataset',
            type: 'string'
        },
        track: {
            description: `The current track/platform information, updated with real-time updates if available. 
Can be missing if neither real-time updates nor the schedule timetable contains track information.
`,
            type: 'string'
        },
        vertexType: {
            '$ref': '#/components/schemas/VertexType'
        }
    }
} as const;

export const StopTimeSchema = {
    description: 'departure or arrival event at a stop',
    type: 'object',
    required: ['place', 'mode', 'realTime', 'headsign', 'agencyId', 'agencyName', 'agencyUrl', 'tripId', 'routeShortName', 'source'],
    properties: {
        place: {
            '$ref': '#/components/schemas/Place',
            description: 'information about the stop place and time'
        },
        mode: {
            '$ref': '#/components/schemas/Mode',
            description: 'Transport mode for this leg'
        },
        realTime: {
            description: 'Whether there is real-time data about this leg',
            type: 'boolean'
        },
        headsign: {
            description: `For transit legs, the headsign of the bus or train being used.
For non-transit legs, null
`,
            type: 'string'
        },
        agencyId: {
            type: 'string'
        },
        agencyName: {
            type: 'string'
        },
        agencyUrl: {
            type: 'string'
        },
        routeColor: {
            type: 'string'
        },
        routeTextColor: {
            type: 'string'
        },
        tripId: {
            type: 'string'
        },
        routeShortName: {
            type: 'string'
        },
        source: {
            description: 'Filename and line number where this trip is from',
            type: 'string'
        }
    }
} as const;

export const TripInfoSchema = {
    description: 'trip id and name',
    type: 'object',
    required: ['tripId', 'routeShortName'],
    properties: {
        tripId: {
            description: 'trip ID (dataset trip id prefixed with the dataset tag)',
            type: 'string'
        },
        routeShortName: {
            description: 'trip display name',
            type: 'string'
        }
    }
} as const;

export const TripSegmentSchema = {
    description: 'trip segment between two stops to show a trip on a map',
    type: 'object',
    required: ['trips', 'mode', 'distance', 'from', 'to', 'departure', 'arrival', 'scheduledArrival', 'scheduledDeparture', 'realTime', 'polyline'],
    properties: {
        trips: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/TripInfo'
            }
        },
        routeColor: {
            type: 'string'
        },
        mode: {
            '$ref': '#/components/schemas/Mode',
            description: 'Transport mode for this leg'
        },
        distance: {
            type: 'number',
            description: 'distance in meters'
        },
        from: {
            '$ref': '#/components/schemas/Place'
        },
        to: {
            '$ref': '#/components/schemas/Place'
        },
        departure: {
            description: 'departure time',
            type: 'string',
            format: 'date-time'
        },
        arrival: {
            description: 'arrival time',
            type: 'string',
            format: 'date-time'
        },
        scheduledDeparture: {
            description: 'scheduled departure time',
            type: 'string',
            format: 'date-time'
        },
        scheduledArrival: {
            description: 'scheduled arrival time',
            type: 'string',
            format: 'date-time'
        },
        realTime: {
            description: 'Whether there is real-time data about this leg',
            type: 'boolean'
        },
        polyline: {
            description: 'Google polyline encoded coordinate sequence (with precision 7) where the trip travels on this segment.',
            type: 'string'
        }
    }
} as const;

export const DirectionSchema = {
    type: 'string',
    enum: ['DEPART', 'HARD_LEFT', 'LEFT', 'SLIGHTLY_LEFT', 'CONTINUE', 'SLIGHTLY_RIGHT', 'RIGHT', 'HARD_RIGHT', 'CIRCLE_CLOCKWISE', 'CIRCLE_COUNTERCLOCKWISE', 'STAIRS', 'ELEVATOR', 'UTURN_LEFT', 'UTURN_RIGHT']
} as const;

export const EncodedPolylineSchema = {
    type: 'object',
    required: ['points', 'length'],
    properties: {
        points: {
            description: 'The encoded points of the polyline using the Google polyline encoding with precision 7.',
            type: 'string'
        },
        length: {
            description: 'The number of points in the string',
            type: 'integer'
        }
    }
} as const;

export const StepInstructionSchema = {
    type: 'object',
    required: ['fromLevel', 'toLevel', 'polyline', 'relativeDirection', 'distance', 'streetName', 'exit', 'stayOn', 'area'],
    properties: {
        relativeDirection: {
            '$ref': '#/components/schemas/Direction'
        },
        distance: {
            description: 'The distance in meters that this step takes.',
            type: 'number'
        },
        fromLevel: {
            description: 'level where this segment starts, based on OpenStreetMap data',
            type: 'number'
        },
        toLevel: {
            description: 'level where this segment starts, based on OpenStreetMap data',
            type: 'number'
        },
        osmWay: {
            description: 'OpenStreetMap way index',
            type: 'integer'
        },
        polyline: {
            '$ref': '#/components/schemas/EncodedPolyline'
        },
        streetName: {
            description: 'The name of the street.',
            type: 'string'
        },
        exit: {
            description: `Not implemented!
When exiting a highway or traffic circle, the exit name/number.
`,
            type: 'string'
        },
        stayOn: {
            description: `Not implemented!
Indicates whether or not a street changes direction at an intersection.
`,
            type: 'boolean'
        },
        area: {
            description: `Not implemented!
This step is on an open area, such as a plaza or train platform,
and thus the directions should say something like "cross"
`,
            type: 'boolean'
        }
    }
} as const;

export const RentalFormFactorSchema = {
    type: 'string',
    enum: ['BICYCLE', 'CARGO_BICYCLE', 'CAR', 'MOPED', 'SCOOTER_STANDING', 'SCOOTER_SEATED', 'OTHER']
} as const;

export const RentalPropulsionTypeSchema = {
    type: 'string',
    enum: ['HUMAN', 'ELECTRIC_ASSIST', 'ELECTRIC', 'COMBUSTION', 'COMBUSTION_DIESEL', 'HYBRID', 'PLUG_IN_HYBRID', 'HYDROGEN_FUEL_CELL']
} as const;

export const RentalReturnConstraintSchema = {
    type: 'string',
    enum: ['NONE', 'ANY_STATION', 'ROUNDTRIP_STATION']
} as const;

export const RentalSchema = {
    description: 'Vehicle rental',
    type: 'object',
    required: ['systemId'],
    properties: {
        systemId: {
            type: 'string',
            description: 'Vehicle share system ID'
        },
        systemName: {
            type: 'string',
            description: 'Vehicle share system name'
        },
        url: {
            type: 'string',
            description: 'URL of the vehicle share system'
        },
        stationName: {
            type: 'string',
            description: 'Name of the station'
        },
        fromStationName: {
            type: 'string',
            description: 'Name of the station where the vehicle is picked up (empty for free floating vehicles)'
        },
        toStationName: {
            type: 'string',
            description: 'Name of the station where the vehicle is returned (empty for free floating vehicles)'
        },
        rentalUriAndroid: {
            type: 'string',
            description: 'Rental URI for Android (deep link to the specific station or vehicle)'
        },
        rentalUriIOS: {
            type: 'string',
            description: 'Rental URI for iOS (deep link to the specific station or vehicle)'
        },
        rentalUriWeb: {
            type: 'string',
            description: 'Rental URI for web (deep link to the specific station or vehicle)'
        },
        formFactor: {
            '$ref': '#/components/schemas/RentalFormFactor'
        },
        propulsionType: {
            '$ref': '#/components/schemas/RentalPropulsionType'
        },
        returnConstraint: {
            '$ref': '#/components/schemas/RentalReturnConstraint'
        }
    }
} as const;

export const LegSchema = {
    type: 'object',
    required: ['mode', 'startTime', 'endTime', 'scheduledStartTime', 'scheduledEndTime', 'realTime', 'duration', 'from', 'to', 'legGeometry'],
    properties: {
        mode: {
            '$ref': '#/components/schemas/Mode',
            description: 'Transport mode for this leg'
        },
        from: {
            '$ref': '#/components/schemas/Place'
        },
        to: {
            '$ref': '#/components/schemas/Place'
        },
        duration: {
            description: `Leg duration in seconds

If leg is footpath:
  The footpath duration is derived from the default footpath
  duration using the query parameters \`transferTimeFactor\` and
  \`additionalTransferTime\` as follows:
  \`leg.duration = defaultDuration * transferTimeFactor + additionalTransferTime.\`
  In case the defaultDuration is needed, it can be calculated by
  \`defaultDuration = (leg.duration - additionalTransferTime) / transferTimeFactor\`.
  Note that the default values are \`transferTimeFactor = 1\` and
  \`additionalTransferTime = 0\` in case they are not explicitly
  provided in the query.
`,
            type: 'integer'
        },
        startTime: {
            type: 'string',
            format: 'date-time',
            description: 'leg departure time'
        },
        endTime: {
            type: 'string',
            format: 'date-time',
            description: 'leg arrival time'
        },
        scheduledStartTime: {
            type: 'string',
            format: 'date-time',
            description: 'scheduled leg departure time'
        },
        scheduledEndTime: {
            type: 'string',
            format: 'date-time',
            description: 'scheduled leg arrival time'
        },
        realTime: {
            description: 'Whether there is real-time data about this leg',
            type: 'boolean'
        },
        distance: {
            description: 'For non-transit legs the distance traveled while traversing this leg in meters.',
            type: 'number'
        },
        interlineWithPreviousLeg: {
            description: 'For transit legs, if the rider should stay on the vehicle as it changes route names.',
            type: 'boolean'
        },
        headsign: {
            description: `For transit legs, the headsign of the bus or train being used.
For non-transit legs, null
`,
            type: 'string'
        },
        routeColor: {
            type: 'string'
        },
        routeTextColor: {
            type: 'string'
        },
        routeType: {
            type: 'string'
        },
        agencyName: {
            type: 'string'
        },
        agencyUrl: {
            type: 'string'
        },
        agencyId: {
            type: 'string'
        },
        tripId: {
            type: 'string'
        },
        routeShortName: {
            type: 'string'
        },
        source: {
            description: 'Filename and line number where this trip is from',
            type: 'string'
        },
        intermediateStops: {
            description: `For transit legs, intermediate stops between the Place where the leg originates
and the Place where the leg ends. For non-transit legs, null.
`,
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Place'
            }
        },
        legGeometry: {
            '$ref': '#/components/schemas/EncodedPolyline'
        },
        steps: {
            description: `A series of turn by turn instructions
used for walking, biking and driving.
`,
            type: 'array',
            items: {
                '$ref': '#/components/schemas/StepInstruction'
            }
        },
        rental: {
            '$ref': '#/components/schemas/Rental'
        },
        fareTransferIndex: {
            type: 'integer',
            description: `Index into \`Itinerary.fareTransfers\` array
to identify which fare transfer this leg belongs to
`
        },
        effectiveFareLegIndex: {
            type: 'integer',
            description: `Index into the \`Itinerary.fareTransfers[fareTransferIndex].effectiveFareLegProducts\` array
to identify which effective fare leg this itinerary leg belongs to
`
        }
    }
} as const;

export const RiderCategorySchema = {
    type: 'object',
    required: ['riderCategoryName', 'isDefaultFareCategory'],
    properties: {
        riderCategoryName: {
            description: 'Rider category name as displayed to the rider.',
            type: 'string'
        },
        isDefaultFareCategory: {
            description: 'Specifies if this category should be considered the default (i.e. the main category displayed to riders).',
            type: 'boolean'
        },
        eligibilityUrl: {
            description: 'URL to a web page providing detailed information about the rider category and/or its eligibility criteria.',
            type: 'string'
        }
    }
} as const;

export const FareMediaTypeSchema = {
    type: 'string',
    enum: ['NONE', 'PAPER_TICKET', 'TRANSIT_CARD', 'CONTACTLESS_EMV', 'MOBILE_APP'],
    enumDescriptions: {
        NONE: 'No fare media involved (e.g., cash payment)',
        PAPER_TICKET: 'Physical paper ticket',
        TRANSIT_CARD: 'Physical transit card with stored value',
        CONTACTLESS_EMV: 'cEMV (contactless payment)',
        MOBILE_APP: 'Mobile app with virtual transit cards/passes'
    }
} as const;

export const FareMediaSchema = {
    type: 'object',
    required: ['fareMediaType'],
    properties: {
        fareMediaName: {
            description: 'Name of the fare media. Required for transit cards and mobile apps.',
            type: 'string'
        },
        fareMediaType: {
            description: 'The type of fare media.',
            '$ref': '#/components/schemas/FareMediaType'
        }
    }
} as const;

export const FareProductSchema = {
    type: 'object',
    required: ['name', 'amount', 'currency'],
    properties: {
        name: {
            description: 'The name of the fare product as displayed to riders.',
            type: 'string'
        },
        amount: {
            description: 'The cost of the fare product. May be negative to represent transfer discounts. May be zero to represent a fare product that is free.',
            type: 'number'
        },
        currency: {
            description: 'ISO 4217 currency code. The currency of the cost of the fare product.',
            type: 'string'
        },
        riderCategory: {
            '$ref': '#/components/schemas/RiderCategory'
        },
        media: {
            '$ref': '#/components/schemas/FareMedia'
        }
    }
} as const;

export const FareTransferRuleSchema = {
    type: 'string',
    enum: ['A_AB', 'A_AB_B', 'AB']
} as const;

export const FareTransferSchema = {
    type: 'object',
    description: `The concept is derived from: https://gtfs.org/documentation/schedule/reference/#fare_transfer_rulestxt

Terminology:
  - **Leg**: An itinerary leg as described by the \`Leg\` type of this API description.
  - **Effective Fare Leg**: Itinerary legs can be joined together to form one *effective fare leg*.
  - **Fare Transfer**: A fare transfer groups two or more effective fare legs.
  - **A** is the first *effective fare leg* of potentially multiple consecutive legs contained in a fare transfer
  - **B** is any *effective fare leg* following the first *effective fare leg* in this transfer
  - **AB** are all changes between *effective fare legs* contained in this transfer

The fare transfer rule is used to derive the final set of products of the itinerary legs contained in this transfer:
  - A_AB means that any product from the first effective fare leg combined with the product attached to the transfer itself (AB) which can be empty (= free). Note that all subsequent effective fare leg products need to be ignored in this case.
  - A_AB_B mean that a product for each effective fare leg needs to be purchased in a addition to the product attached to the transfer itself (AB) which can be empty (= free)
  - AB only the transfer product itself has to be purchased. Note that all fare products attached to the contained effective fare legs need to be ignored in this case.

An itinerary \`Leg\` references the index of the fare transfer and the index of the effective fare leg in this transfer it belongs to.
`,
    required: ['effectiveFareLegProducts'],
    properties: {
        rule: {
            '$ref': '#/components/schemas/FareTransferRule'
        },
        transferProduct: {
            '$ref': '#/components/schemas/FareProduct'
        },
        effectiveFareLegProducts: {
            description: `Lists all valid fare products for the effective fare legs.
This is an \`array<array<FareProduct>>\` where the inner array
lists all possible fare products that would cover this effective fare leg.
Each "effective fare leg" can have multiple options for adult/child/weekly/monthly/day/one-way tickets etc.
You can see the outer array as AND (you need one ticket for each effective fare leg (\`A_AB_B\`), the first effective fare leg (\`A_AB\`) or no fare leg at all but only the transfer product (\`AB\`)
and the inner array as OR (you can choose which ticket to buy)
`,
            type: 'array',
            items: {
                type: 'array',
                items: {
                    '$ref': '#/components/schemas/FareProduct'
                }
            }
        }
    }
} as const;

export const ItinerarySchema = {
    type: 'object',
    required: ['duration', 'startTime', 'endTime', 'transfers', 'legs'],
    properties: {
        duration: {
            description: 'journey duration in seconds',
            type: 'integer'
        },
        startTime: {
            type: 'string',
            format: 'date-time',
            description: 'journey departure time'
        },
        endTime: {
            type: 'string',
            format: 'date-time',
            description: 'journey arrival time'
        },
        transfers: {
            type: 'integer',
            description: 'The number of transfers this trip has.'
        },
        legs: {
            description: 'Journey legs',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Leg'
            }
        },
        fareTransfers: {
            description: 'Fare information',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/FareTransfer'
            }
        }
    }
} as const;

export const FootpathSchema = {
    description: 'footpath from one location to another',
    type: 'object',
    required: ['to'],
    properties: {
        to: {
            '$ref': '#/components/schemas/Place'
        },
        default: {
            type: 'number',
            description: `optional; missing if the GTFS did not contain a footpath
footpath duration in minutes according to GTFS (+heuristics)
`
        },
        foot: {
            type: 'number',
            description: `optional; missing if no path was found (timetable / osr)
footpath duration in minutes for the foot profile
`
        },
        footRouted: {
            type: 'number',
            description: `optional; missing if no path was found with foot routing
footpath duration in minutes for the foot profile
`
        },
        wheelchair: {
            type: 'number',
            description: `optional; missing if no path was found with the wheelchair profile 
footpath duration in minutes for the wheelchair profile
`
        },
        wheelchairUsesElevator: {
            type: 'boolean',
            description: `optional; missing if no path was found with the wheelchair profile
true if the wheelchair path uses an elevator
`
        }
    }
} as const;