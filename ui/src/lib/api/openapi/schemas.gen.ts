// This file is auto-generated by @hey-api/openapi-ts

export const AlertCauseSchema = {
    description: 'Cause of this alert.',
    type: 'string',
    enum: ['UNKNOWN_CAUSE', 'OTHER_CAUSE', 'TECHNICAL_PROBLEM', 'STRIKE', 'DEMONSTRATION', 'ACCIDENT', 'HOLIDAY', 'WEATHER', 'MAINTENANCE', 'CONSTRUCTION', 'POLICE_ACTIVITY', 'MEDICAL_EMERGENCY']
} as const;

export const AlertEffectSchema = {
    description: 'The effect of this problem on the affected entity.',
    type: 'string',
    enum: ['NO_SERVICE', 'REDUCED_SERVICE', 'SIGNIFICANT_DELAYS', 'DETOUR', 'ADDITIONAL_SERVICE', 'MODIFIED_SERVICE', 'OTHER_EFFECT', 'UNKNOWN_EFFECT', 'STOP_MOVED', 'NO_EFFECT', 'ACCESSIBILITY_ISSUE']
} as const;

export const AlertSeverityLevelSchema = {
    description: 'The severity of the alert.',
    type: 'string',
    enum: ['UNKNOWN_SEVERITY', 'INFO', 'WARNING', 'SEVERE']
} as const;

export const TimeRangeSchema = {
    description: `A time interval.
The interval is considered active at time t if t is greater than or equal to the start time and less than the end time.
`,
    type: 'object',
    properties: {
        start: {
            description: `If missing, the interval starts at minus infinity.
If a TimeRange is provided, either start or end must be provided - both fields cannot be empty.
`,
            type: 'string',
            format: 'date-time'
        },
        end: {
            description: `If missing, the interval ends at plus infinity.
If a TimeRange is provided, either start or end must be provided - both fields cannot be empty.
`,
            type: 'string',
            format: 'date-time'
        }
    }
} as const;

export const AlertSchema = {
    description: 'An alert, indicating some sort of incident in the public transit network.',
    type: 'object',
    required: ['headerText', 'descriptionText'],
    properties: {
        communicationPeriod: {
            description: `Time when the alert should be shown to the user.
If missing, the alert will be shown as long as it appears in the feed.
If multiple ranges are given, the alert will be shown during all of them.
`,
            type: 'array',
            items: {
                '$ref': '#/components/schemas/TimeRange'
            }
        },
        impactPeriod: {
            description: 'Time when the services are affected by the disruption mentioned in the alert.',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/TimeRange'
            }
        },
        cause: {
            '$ref': '#/components/schemas/AlertCause'
        },
        causeDetail: {
            type: 'string',
            description: `Description of the cause of the alert that allows for agency-specific language;
more specific than the Cause.
`
        },
        effect: {
            '$ref': '#/components/schemas/AlertEffect'
        },
        effectDetail: {
            type: 'string',
            description: `Description of the effect of the alert that allows for agency-specific language;
more specific than the Effect.
`
        },
        url: {
            type: 'string',
            description: 'The URL which provides additional information about the alert.'
        },
        headerText: {
            type: 'string',
            description: `Header for the alert. This plain-text string will be highlighted, for example in boldface.
`
        },
        descriptionText: {
            type: 'string',
            description: `Description for the alert.
This plain-text string will be formatted as the body of the alert (or shown on an explicit "expand" request by the user).
The information in the description should add to the information of the header.
`
        },
        ttsHeaderText: {
            type: 'string',
            description: `Text containing the alert's header to be used for text-to-speech implementations.
This field is the text-to-speech version of header_text.
It should contain the same information as headerText but formatted such that it can read as text-to-speech
(for example, abbreviations removed, numbers spelled out, etc.)
`
        },
        ttsDescriptionText: {
            type: 'string',
            description: `Text containing a description for the alert to be used for text-to-speech implementations.
This field is the text-to-speech version of description_text.
It should contain the same information as description_text but formatted such that it can be read as text-to-speech
(for example, abbreviations removed, numbers spelled out, etc.)
`
        },
        severityLevel: {
            description: 'Severity of the alert.',
            '$ref': '#/components/schemas/AlertSeverityLevel'
        },
        imageUrl: {
            description: 'String containing an URL linking to an image.',
            type: 'string'
        },
        imageMediaType: {
            description: `IANA media type as to specify the type of image to be displayed. The type must start with "image/"
`,
            type: 'string'
        },
        imageAlternativeText: {
            description: `Text describing the appearance of the linked image in the image field
(e.g., in case the image can't be displayed or the user can't see the image for accessibility reasons).
See the HTML spec for alt image text.
`,
            type: 'string'
        }
    }
} as const;

export const DurationSchema = {
    description: 'Object containing duration if a path was found or none if no path was found',
    type: 'object',
    properties: {
        duration: {
            type: 'number',
            description: 'duration in seconds if a path was found, otherwise missing'
        }
    }
} as const;

export const AreaSchema = {
    description: 'Administrative area',
    type: 'object',
    required: ['name', 'adminLevel', 'matched'],
    properties: {
        name: {
            type: 'string',
            description: 'Name of the area'
        },
        adminLevel: {
            type: 'number',
            description: `[OpenStreetMap \`admin_level\`](https://wiki.openstreetmap.org/wiki/Key:admin_level)
of the area
`
        },
        matched: {
            type: 'boolean',
            description: 'Whether this area was matched by the input text'
        },
        unique: {
            type: 'boolean',
            description: `Set for the first area after the \`default\` area that distinguishes areas
if the match is ambiguous regarding (\`default\` area + place name / street [+ house number]).
`
        },
        default: {
            type: 'boolean',
            description: 'Whether this area should be displayed as default area (area with admin level closest 7)'
        }
    }
} as const;

export const TokenSchema = {
    description: 'Matched token range (from index, length)',
    type: 'array',
    minItems: 2,
    maxItems: 2,
    items: {
        type: 'number'
    }
} as const;

export const LocationTypeSchema = {
    description: 'location type',
    type: 'string',
    enum: ['ADDRESS', 'PLACE', 'STOP']
} as const;

export const MatchSchema = {
    description: 'GeoCoding match',
    type: 'object',
    required: ['type', 'name', 'id', 'lat', 'lon', 'tokens', 'areas', 'score'],
    properties: {
        type: {
            '$ref': '#/components/schemas/LocationType'
        },
        tokens: {
            description: 'list of non-overlapping tokens that were matched',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Token'
            }
        },
        name: {
            description: 'name of the location (transit stop / PoI / address)',
            type: 'string'
        },
        id: {
            description: 'unique ID of the location',
            type: 'string'
        },
        lat: {
            description: 'latitude',
            type: 'number'
        },
        lon: {
            description: 'longitude',
            type: 'number'
        },
        level: {
            description: `level according to OpenStreetMap
(at the moment only for public transport)
`,
            type: 'number'
        },
        street: {
            description: 'street name',
            type: 'string'
        },
        houseNumber: {
            description: 'house number',
            type: 'string'
        },
        zip: {
            description: 'zip code',
            type: 'string'
        },
        areas: {
            description: 'list of areas',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Area'
            }
        },
        score: {
            description: 'score according to the internal scoring system (the scoring algorithm might change in the future)',
            type: 'number'
        }
    }
} as const;

export const ElevationCostsSchema = {
    description: `Different elevation cost profiles for street routing.
Using a elevation cost profile will prefer routes with a smaller incline and smaller difference in elevation, even if the routed way is longer.

- \`NONE\`: Ignore elevation data for routing. This is the default behavior
- \`LOW\`: Add a low penalty for inclines. This will favor longer paths, if the elevation increase and incline are smaller.
- \`HIGH\`: Add a high penalty for inclines. This will favor even longer paths, if the elevation increase and incline are smaller.
`,
    type: 'string',
    enum: ['NONE', 'LOW', 'HIGH']
} as const;

export const PedestrianProfileSchema = {
    description: 'Different accessibility profiles for pedestrians.',
    type: 'string',
    enum: ['FOOT', 'WHEELCHAIR']
} as const;

export const ModeSchema = {
    description: `# Street modes

  - \`WALK\`
  - \`BIKE\`
  - \`RENTAL\` Experimental. Expect unannounced breaking changes (without version bumps) for all parameters and returned structs.
  - \`CAR\`
  - \`CAR_PARKING\` Experimental. Expect unannounced breaking changes (without version bumps) for all parameters and returned structs.
  - \`ODM\` on-demand taxis from the Prima+ÖV Project
  - \`FLEX\` flexible transports

# Transit modes

  - \`TRANSIT\`: translates to \`RAIL,SUBWAY,TRAM,BUS,FERRY,AIRPLANE,COACH\`
  - \`TRAM\`: trams
  - \`SUBWAY\`: subway trains
  - \`FERRY\`: ferries
  - \`AIRPLANE\`: airline flights
  - \`BUS\`: short distance buses (does not include \`COACH\`)
  - \`COACH\`: long distance buses (does not include \`BUS\`)
  - \`RAIL\`: translates to \`HIGHSPEED_RAIL,LONG_DISTANCE_RAIL,NIGHT_RAIL,REGIONAL_RAIL,REGIONAL_FAST_RAIL\`
  - \`METRO\`: metro trains 
  - \`HIGHSPEED_RAIL\`: long distance high speed trains (e.g. TGV)
  - \`LONG_DISTANCE\`: long distance inter city trains
  - \`NIGHT_RAIL\`: long distance night trains
  - \`REGIONAL_FAST_RAIL\`: regional express routes that skip low traffic stops to be faster
  - \`REGIONAL_RAIL\`: regional train
  - \`CABLE_CAR\`: Cable tram. Used for street-level rail cars where the cable runs beneath the vehicle (e.g., cable car in San Francisco).
  - \`FUNICULAR\`: Funicular. Any rail system designed for steep inclines.
  - \`AREAL_LIFT\`: Aerial lift, suspended cable car (e.g., gondola lift, aerial tramway). Cable transport where cabins, cars, gondolas or open chairs are suspended by means of one or more cables.
`,
    type: 'string',
    enum: ['WALK', 'BIKE', 'RENTAL', 'CAR', 'CAR_PARKING', 'ODM', 'FLEX', 'TRANSIT', 'TRAM', 'SUBWAY', 'FERRY', 'AIRPLANE', 'METRO', 'BUS', 'COACH', 'RAIL', 'HIGHSPEED_RAIL', 'LONG_DISTANCE', 'NIGHT_RAIL', 'REGIONAL_FAST_RAIL', 'REGIONAL_RAIL', 'CABLE_CAR', 'FUNICULAR', 'AREAL_LIFT', 'OTHER']
} as const;

export const VertexTypeSchema = {
    type: 'string',
    description: `- \`NORMAL\` - latitude / longitude coordinate or address
- \`BIKESHARE\` - bike sharing station
- \`TRANSIT\` - transit stop
`,
    enum: ['NORMAL', 'BIKESHARE', 'TRANSIT']
} as const;

export const PickupDropoffTypeSchema = {
    type: 'string',
    description: `- \`NORMAL\` - entry/exit is possible normally
- \`NOT_ALLOWED\` - entry/exit is not allowed
`,
    enum: ['NORMAL', 'NOT_ALLOWED']
} as const;

export const PlaceSchema = {
    type: 'object',
    required: ['name', 'lat', 'lon', 'level'],
    properties: {
        name: {
            description: 'name of the transit stop / PoI / address',
            type: 'string'
        },
        stopId: {
            description: "The ID of the stop. This is often something that users don't care about.",
            type: 'string'
        },
        lat: {
            description: 'latitude',
            type: 'number'
        },
        lon: {
            description: 'longitude',
            type: 'number'
        },
        level: {
            description: 'level according to OpenStreetMap',
            type: 'number'
        },
        arrival: {
            description: 'arrival time',
            type: 'string',
            format: 'date-time'
        },
        departure: {
            description: 'departure time',
            type: 'string',
            format: 'date-time'
        },
        scheduledArrival: {
            description: 'scheduled arrival time',
            type: 'string',
            format: 'date-time'
        },
        scheduledDeparture: {
            description: 'scheduled departure time',
            type: 'string',
            format: 'date-time'
        },
        scheduledTrack: {
            description: 'scheduled track from the static schedule timetable dataset',
            type: 'string'
        },
        track: {
            description: `The current track/platform information, updated with real-time updates if available. 
Can be missing if neither real-time updates nor the schedule timetable contains track information.
`,
            type: 'string'
        },
        vertexType: {
            '$ref': '#/components/schemas/VertexType'
        },
        pickupType: {
            description: 'Type of pickup. It could be disallowed due to schedule, skipped stops or cancellations.',
            '$ref': '#/components/schemas/PickupDropoffType'
        },
        dropoffType: {
            description: 'Type of dropoff. It could be disallowed due to schedule, skipped stops or cancellations.',
            '$ref': '#/components/schemas/PickupDropoffType'
        },
        cancelled: {
            description: 'Whether this stop is cancelled due to the realtime situation.',
            type: 'boolean'
        },
        alerts: {
            description: 'Alerts for this stop.',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Alert'
            }
        },
        flex: {
            description: 'for `FLEX` transports, the flex location area or location group name',
            type: 'string'
        },
        flexId: {
            description: 'for `FLEX` transports, the flex location area ID or location group ID',
            type: 'string'
        },
        flexStartPickupDropOffWindow: {
            description: 'Time that on-demand service becomes available',
            type: 'string',
            format: 'date-time'
        },
        flexEndPickupDropOffWindow: {
            description: 'Time that on-demand service ends',
            type: 'string',
            format: 'date-time'
        }
    }
} as const;

export const ReachablePlaceSchema = {
    description: 'Place reachable by One-to-All',
    type: 'object',
    properties: {
        place: {
            '$ref': '#/components/schemas/Place',
            description: 'Place reached by One-to-All'
        },
        duration: {
            type: 'integer',
            description: 'Total travel duration'
        },
        k: {
            type: 'integer',
            description: `k is the smallest number, for which a journey with the shortest duration and at most k-1 transfers exist.
You can think of k as the number of connections used.

In more detail:

k=0: No connection, e.g. for the one location
k=1: Direct connection
k=2: Connection with 1 transfer
`
        }
    }
} as const;

export const ReachableSchema = {
    description: 'Object containing all reachable places by One-to-All search',
    type: 'object',
    properties: {
        one: {
            '$ref': '#/components/schemas/Place',
            description: 'One location used in One-to-All search'
        },
        all: {
            description: 'List of locations reachable by One-to-All',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/ReachablePlace'
            }
        }
    }
} as const;

export const StopTimeSchema = {
    description: 'departure or arrival event at a stop',
    type: 'object',
    required: ['place', 'mode', 'realTime', 'headsign', 'agencyId', 'agencyName', 'agencyUrl', 'tripId', 'routeShortName', 'pickupDropoffType', 'cancelled', 'source'],
    properties: {
        place: {
            '$ref': '#/components/schemas/Place',
            description: 'information about the stop place and time'
        },
        mode: {
            '$ref': '#/components/schemas/Mode',
            description: 'Transport mode for this leg'
        },
        realTime: {
            description: 'Whether there is real-time data about this leg',
            type: 'boolean'
        },
        headsign: {
            description: `For transit legs, the headsign of the bus or train being used.
For non-transit legs, null
`,
            type: 'string'
        },
        agencyId: {
            type: 'string'
        },
        agencyName: {
            type: 'string'
        },
        agencyUrl: {
            type: 'string'
        },
        routeColor: {
            type: 'string'
        },
        routeTextColor: {
            type: 'string'
        },
        tripId: {
            type: 'string'
        },
        routeShortName: {
            type: 'string'
        },
        pickupDropoffType: {
            description: 'Type of pickup (for departures) or dropoff (for arrivals), may be disallowed either due to schedule, skipped stops or cancellations',
            '$ref': '#/components/schemas/PickupDropoffType'
        },
        cancelled: {
            description: 'Whether the departure/arrival is cancelled due to the realtime situation.',
            type: 'boolean'
        },
        source: {
            description: 'Filename and line number where this trip is from',
            type: 'string'
        }
    }
} as const;

export const TripInfoSchema = {
    description: 'trip id and name',
    type: 'object',
    required: ['tripId', 'routeShortName'],
    properties: {
        tripId: {
            description: 'trip ID (dataset trip id prefixed with the dataset tag)',
            type: 'string'
        },
        routeShortName: {
            description: 'trip display name',
            type: 'string'
        }
    }
} as const;

export const TripSegmentSchema = {
    description: 'trip segment between two stops to show a trip on a map',
    type: 'object',
    required: ['trips', 'mode', 'distance', 'from', 'to', 'departure', 'arrival', 'scheduledArrival', 'scheduledDeparture', 'realTime', 'polyline'],
    properties: {
        trips: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/TripInfo'
            }
        },
        routeColor: {
            type: 'string'
        },
        mode: {
            '$ref': '#/components/schemas/Mode',
            description: 'Transport mode for this leg'
        },
        distance: {
            type: 'number',
            description: 'distance in meters'
        },
        from: {
            '$ref': '#/components/schemas/Place'
        },
        to: {
            '$ref': '#/components/schemas/Place'
        },
        departure: {
            description: 'departure time',
            type: 'string',
            format: 'date-time'
        },
        arrival: {
            description: 'arrival time',
            type: 'string',
            format: 'date-time'
        },
        scheduledDeparture: {
            description: 'scheduled departure time',
            type: 'string',
            format: 'date-time'
        },
        scheduledArrival: {
            description: 'scheduled arrival time',
            type: 'string',
            format: 'date-time'
        },
        realTime: {
            description: 'Whether there is real-time data about this leg',
            type: 'boolean'
        },
        polyline: {
            description: 'Google polyline encoded coordinate sequence (with precision 5) where the trip travels on this segment.',
            type: 'string'
        }
    }
} as const;

export const DirectionSchema = {
    type: 'string',
    enum: ['DEPART', 'HARD_LEFT', 'LEFT', 'SLIGHTLY_LEFT', 'CONTINUE', 'SLIGHTLY_RIGHT', 'RIGHT', 'HARD_RIGHT', 'CIRCLE_CLOCKWISE', 'CIRCLE_COUNTERCLOCKWISE', 'STAIRS', 'ELEVATOR', 'UTURN_LEFT', 'UTURN_RIGHT']
} as const;

export const EncodedPolylineSchema = {
    type: 'object',
    required: ['points', 'precision', 'length'],
    properties: {
        points: {
            description: 'The encoded points of the polyline using the Google polyline encoding.',
            type: 'string'
        },
        precision: {
            description: `The precision of the returned polyline (7 for /v1, 6 for /v2)
Be aware that with precision 7, coordinates with |longitude| > 107.37 are undefined/will overflow.
`,
            type: 'integer'
        },
        length: {
            description: 'The number of points in the string',
            type: 'integer',
            minimum: 0
        }
    }
} as const;

export const StepInstructionSchema = {
    type: 'object',
    required: ['fromLevel', 'toLevel', 'polyline', 'relativeDirection', 'distance', 'streetName', 'exit', 'stayOn', 'area'],
    properties: {
        relativeDirection: {
            '$ref': '#/components/schemas/Direction'
        },
        distance: {
            description: 'The distance in meters that this step takes.',
            type: 'number'
        },
        fromLevel: {
            description: 'level where this segment starts, based on OpenStreetMap data',
            type: 'number'
        },
        toLevel: {
            description: 'level where this segment starts, based on OpenStreetMap data',
            type: 'number'
        },
        osmWay: {
            description: 'OpenStreetMap way index',
            type: 'integer'
        },
        polyline: {
            '$ref': '#/components/schemas/EncodedPolyline'
        },
        streetName: {
            description: 'The name of the street.',
            type: 'string'
        },
        exit: {
            description: `Not implemented!
When exiting a highway or traffic circle, the exit name/number.
`,
            type: 'string'
        },
        stayOn: {
            description: `Not implemented!
Indicates whether or not a street changes direction at an intersection.
`,
            type: 'boolean'
        },
        area: {
            description: `Not implemented!
This step is on an open area, such as a plaza or train platform,
and thus the directions should say something like "cross"
`,
            type: 'boolean'
        },
        toll: {
            description: 'Indicates that a fee must be paid by general traffic to use a road, road bridge or road tunnel.',
            type: 'boolean'
        },
        accessRestriction: {
            description: `Experimental. Indicates whether access to this part of the route is restricted.
See: https://wiki.openstreetmap.org/wiki/Conditional_restrictions
`,
            type: 'string'
        },
        elevationUp: {
            type: 'integer',
            description: 'incline in meters across this path segment'
        },
        elevationDown: {
            type: 'integer',
            description: 'decline in meters across this path segment'
        }
    }
} as const;

export const RentalFormFactorSchema = {
    type: 'string',
    enum: ['BICYCLE', 'CARGO_BICYCLE', 'CAR', 'MOPED', 'SCOOTER_STANDING', 'SCOOTER_SEATED', 'OTHER']
} as const;

export const RentalPropulsionTypeSchema = {
    type: 'string',
    enum: ['HUMAN', 'ELECTRIC_ASSIST', 'ELECTRIC', 'COMBUSTION', 'COMBUSTION_DIESEL', 'HYBRID', 'PLUG_IN_HYBRID', 'HYDROGEN_FUEL_CELL']
} as const;

export const RentalReturnConstraintSchema = {
    type: 'string',
    enum: ['NONE', 'ANY_STATION', 'ROUNDTRIP_STATION']
} as const;

export const RentalSchema = {
    description: 'Vehicle rental',
    type: 'object',
    required: ['systemId'],
    properties: {
        systemId: {
            type: 'string',
            description: 'Vehicle share system ID'
        },
        systemName: {
            type: 'string',
            description: 'Vehicle share system name'
        },
        url: {
            type: 'string',
            description: 'URL of the vehicle share system'
        },
        stationName: {
            type: 'string',
            description: 'Name of the station'
        },
        fromStationName: {
            type: 'string',
            description: 'Name of the station where the vehicle is picked up (empty for free floating vehicles)'
        },
        toStationName: {
            type: 'string',
            description: 'Name of the station where the vehicle is returned (empty for free floating vehicles)'
        },
        rentalUriAndroid: {
            type: 'string',
            description: 'Rental URI for Android (deep link to the specific station or vehicle)'
        },
        rentalUriIOS: {
            type: 'string',
            description: 'Rental URI for iOS (deep link to the specific station or vehicle)'
        },
        rentalUriWeb: {
            type: 'string',
            description: 'Rental URI for web (deep link to the specific station or vehicle)'
        },
        formFactor: {
            '$ref': '#/components/schemas/RentalFormFactor'
        },
        propulsionType: {
            '$ref': '#/components/schemas/RentalPropulsionType'
        },
        returnConstraint: {
            '$ref': '#/components/schemas/RentalReturnConstraint'
        }
    }
} as const;

export const LegSchema = {
    type: 'object',
    required: ['mode', 'startTime', 'endTime', 'scheduledStartTime', 'scheduledEndTime', 'realTime', 'scheduled', 'duration', 'from', 'to', 'legGeometry'],
    properties: {
        mode: {
            '$ref': '#/components/schemas/Mode',
            description: 'Transport mode for this leg'
        },
        from: {
            '$ref': '#/components/schemas/Place'
        },
        to: {
            '$ref': '#/components/schemas/Place'
        },
        duration: {
            description: `Leg duration in seconds

If leg is footpath:
  The footpath duration is derived from the default footpath
  duration using the query parameters \`transferTimeFactor\` and
  \`additionalTransferTime\` as follows:
  \`leg.duration = defaultDuration * transferTimeFactor + additionalTransferTime.\`
  In case the defaultDuration is needed, it can be calculated by
  \`defaultDuration = (leg.duration - additionalTransferTime) / transferTimeFactor\`.
  Note that the default values are \`transferTimeFactor = 1\` and
  \`additionalTransferTime = 0\` in case they are not explicitly
  provided in the query.
`,
            type: 'integer'
        },
        startTime: {
            type: 'string',
            format: 'date-time',
            description: 'leg departure time'
        },
        endTime: {
            type: 'string',
            format: 'date-time',
            description: 'leg arrival time'
        },
        scheduledStartTime: {
            type: 'string',
            format: 'date-time',
            description: 'scheduled leg departure time'
        },
        scheduledEndTime: {
            type: 'string',
            format: 'date-time',
            description: 'scheduled leg arrival time'
        },
        realTime: {
            description: 'Whether there is real-time data about this leg',
            type: 'boolean'
        },
        scheduled: {
            description: `Whether this leg was originally scheduled to run or is an additional service.
Scheduled times will equal realtime times in this case.
`,
            type: 'boolean'
        },
        distance: {
            description: 'For non-transit legs the distance traveled while traversing this leg in meters.',
            type: 'number'
        },
        interlineWithPreviousLeg: {
            description: 'For transit legs, if the rider should stay on the vehicle as it changes route names.',
            type: 'boolean'
        },
        headsign: {
            description: `For transit legs, the headsign of the bus or train being used.
For non-transit legs, null
`,
            type: 'string'
        },
        routeColor: {
            type: 'string'
        },
        routeTextColor: {
            type: 'string'
        },
        routeType: {
            type: 'string'
        },
        agencyName: {
            type: 'string'
        },
        agencyUrl: {
            type: 'string'
        },
        agencyId: {
            type: 'string'
        },
        tripId: {
            type: 'string'
        },
        routeShortName: {
            type: 'string'
        },
        cancelled: {
            description: 'Whether this trip is cancelled',
            type: 'boolean'
        },
        source: {
            description: 'Filename and line number where this trip is from',
            type: 'string'
        },
        intermediateStops: {
            description: `For transit legs, intermediate stops between the Place where the leg originates
and the Place where the leg ends. For non-transit legs, null.
`,
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Place'
            }
        },
        legGeometry: {
            '$ref': '#/components/schemas/EncodedPolyline'
        },
        steps: {
            description: `A series of turn by turn instructions
used for walking, biking and driving.
`,
            type: 'array',
            items: {
                '$ref': '#/components/schemas/StepInstruction'
            }
        },
        rental: {
            '$ref': '#/components/schemas/Rental'
        },
        fareTransferIndex: {
            type: 'integer',
            description: `Index into \`Itinerary.fareTransfers\` array
to identify which fare transfer this leg belongs to
`
        },
        effectiveFareLegIndex: {
            type: 'integer',
            description: `Index into the \`Itinerary.fareTransfers[fareTransferIndex].effectiveFareLegProducts\` array
to identify which effective fare leg this itinerary leg belongs to
`
        },
        alerts: {
            description: 'Alerts for this stop.',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Alert'
            }
        }
    }
} as const;

export const RiderCategorySchema = {
    type: 'object',
    required: ['riderCategoryName', 'isDefaultFareCategory'],
    properties: {
        riderCategoryName: {
            description: 'Rider category name as displayed to the rider.',
            type: 'string'
        },
        isDefaultFareCategory: {
            description: 'Specifies if this category should be considered the default (i.e. the main category displayed to riders).',
            type: 'boolean'
        },
        eligibilityUrl: {
            description: 'URL to a web page providing detailed information about the rider category and/or its eligibility criteria.',
            type: 'string'
        }
    }
} as const;

export const FareMediaTypeSchema = {
    type: 'string',
    enum: ['NONE', 'PAPER_TICKET', 'TRANSIT_CARD', 'CONTACTLESS_EMV', 'MOBILE_APP'],
    enumDescriptions: {
        NONE: 'No fare media involved (e.g., cash payment)',
        PAPER_TICKET: 'Physical paper ticket',
        TRANSIT_CARD: 'Physical transit card with stored value',
        CONTACTLESS_EMV: 'cEMV (contactless payment)',
        MOBILE_APP: 'Mobile app with virtual transit cards/passes'
    }
} as const;

export const FareMediaSchema = {
    type: 'object',
    required: ['fareMediaType'],
    properties: {
        fareMediaName: {
            description: 'Name of the fare media. Required for transit cards and mobile apps.',
            type: 'string'
        },
        fareMediaType: {
            description: 'The type of fare media.',
            '$ref': '#/components/schemas/FareMediaType'
        }
    }
} as const;

export const FareProductSchema = {
    type: 'object',
    required: ['name', 'amount', 'currency'],
    properties: {
        name: {
            description: 'The name of the fare product as displayed to riders.',
            type: 'string'
        },
        amount: {
            description: 'The cost of the fare product. May be negative to represent transfer discounts. May be zero to represent a fare product that is free.',
            type: 'number'
        },
        currency: {
            description: 'ISO 4217 currency code. The currency of the cost of the fare product.',
            type: 'string'
        },
        riderCategory: {
            '$ref': '#/components/schemas/RiderCategory'
        },
        media: {
            '$ref': '#/components/schemas/FareMedia'
        }
    }
} as const;

export const FareTransferRuleSchema = {
    type: 'string',
    enum: ['A_AB', 'A_AB_B', 'AB']
} as const;

export const FareTransferSchema = {
    type: 'object',
    description: `The concept is derived from: https://gtfs.org/documentation/schedule/reference/#fare_transfer_rulestxt

Terminology:
  - **Leg**: An itinerary leg as described by the \`Leg\` type of this API description.
  - **Effective Fare Leg**: Itinerary legs can be joined together to form one *effective fare leg*.
  - **Fare Transfer**: A fare transfer groups two or more effective fare legs.
  - **A** is the first *effective fare leg* of potentially multiple consecutive legs contained in a fare transfer
  - **B** is any *effective fare leg* following the first *effective fare leg* in this transfer
  - **AB** are all changes between *effective fare legs* contained in this transfer

The fare transfer rule is used to derive the final set of products of the itinerary legs contained in this transfer:
  - A_AB means that any product from the first effective fare leg combined with the product attached to the transfer itself (AB) which can be empty (= free). Note that all subsequent effective fare leg products need to be ignored in this case.
  - A_AB_B mean that a product for each effective fare leg needs to be purchased in a addition to the product attached to the transfer itself (AB) which can be empty (= free)
  - AB only the transfer product itself has to be purchased. Note that all fare products attached to the contained effective fare legs need to be ignored in this case.

An itinerary \`Leg\` references the index of the fare transfer and the index of the effective fare leg in this transfer it belongs to.
`,
    required: ['effectiveFareLegProducts'],
    properties: {
        rule: {
            '$ref': '#/components/schemas/FareTransferRule'
        },
        transferProducts: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/FareProduct'
            }
        },
        effectiveFareLegProducts: {
            description: `Lists all valid fare products for the effective fare legs.
This is an \`array<array<FareProduct>>\` where the inner array
lists all possible fare products that would cover this effective fare leg.
Each "effective fare leg" can have multiple options for adult/child/weekly/monthly/day/one-way tickets etc.
You can see the outer array as AND (you need one ticket for each effective fare leg (\`A_AB_B\`), the first effective fare leg (\`A_AB\`) or no fare leg at all but only the transfer product (\`AB\`)
and the inner array as OR (you can choose which ticket to buy)
`,
            type: 'array',
            items: {
                type: 'array',
                items: {
                    type: 'array',
                    items: {
                        '$ref': '#/components/schemas/FareProduct'
                    }
                }
            }
        }
    }
} as const;

export const ItinerarySchema = {
    type: 'object',
    required: ['duration', 'startTime', 'endTime', 'transfers', 'legs'],
    properties: {
        duration: {
            description: 'journey duration in seconds',
            type: 'integer'
        },
        startTime: {
            type: 'string',
            format: 'date-time',
            description: 'journey departure time'
        },
        endTime: {
            type: 'string',
            format: 'date-time',
            description: 'journey arrival time'
        },
        transfers: {
            type: 'integer',
            description: 'The number of transfers this trip has.'
        },
        legs: {
            description: 'Journey legs',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Leg'
            }
        },
        fareTransfers: {
            description: 'Fare information',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/FareTransfer'
            }
        }
    }
} as const;

export const TransferSchema = {
    description: 'transfer from one location to another',
    type: 'object',
    required: ['to'],
    properties: {
        to: {
            '$ref': '#/components/schemas/Place'
        },
        default: {
            type: 'number',
            description: `optional; missing if the GTFS did not contain a transfer
transfer duration in minutes according to GTFS (+heuristics)
`
        },
        foot: {
            type: 'number',
            description: `optional; missing if no path was found (timetable / osr)
transfer duration in minutes for the foot profile
`
        },
        footRouted: {
            type: 'number',
            description: `optional; missing if no path was found with foot routing
transfer duration in minutes for the foot profile
`
        },
        wheelchair: {
            type: 'number',
            description: `optional; missing if no path was found with the wheelchair profile 
transfer duration in minutes for the wheelchair profile
`
        },
        wheelchairRouted: {
            type: 'number',
            description: `optional; missing if no path was found with the wheelchair profile
transfer duration in minutes for the wheelchair profile
`
        },
        wheelchairUsesElevator: {
            type: 'boolean',
            description: `optional; missing if no path was found with the wheelchair profile
true if the wheelchair path uses an elevator
`
        },
        car: {
            type: 'number',
            description: `optional; missing if no path was found with car routing
transfer duration in minutes for the car profile
`
        }
    }
} as const;