// This file is auto-generated by @hey-api/openapi-ts

/**
 * Cause of this alert.
 */
export type AlertCause = 'UNKNOWN_CAUSE' | 'OTHER_CAUSE' | 'TECHNICAL_PROBLEM' | 'STRIKE' | 'DEMONSTRATION' | 'ACCIDENT' | 'HOLIDAY' | 'WEATHER' | 'MAINTENANCE' | 'CONSTRUCTION' | 'POLICE_ACTIVITY' | 'MEDICAL_EMERGENCY';

/**
 * The effect of this problem on the affected entity.
 */
export type AlertEffect = 'NO_SERVICE' | 'REDUCED_SERVICE' | 'SIGNIFICANT_DELAYS' | 'DETOUR' | 'ADDITIONAL_SERVICE' | 'MODIFIED_SERVICE' | 'OTHER_EFFECT' | 'UNKNOWN_EFFECT' | 'STOP_MOVED' | 'NO_EFFECT' | 'ACCESSIBILITY_ISSUE';

/**
 * The severity of the alert.
 */
export type AlertSeverityLevel = 'UNKNOWN_SEVERITY' | 'INFO' | 'WARNING' | 'SEVERE';

/**
 * A time interval.
 * The interval is considered active at time t if t is greater than or equal to the start time and less than the end time.
 *
 */
export type TimeRange = {
    /**
     * If missing, the interval starts at minus infinity.
     * If a TimeRange is provided, either start or end must be provided - both fields cannot be empty.
     *
     */
    start?: string;
    /**
     * If missing, the interval ends at plus infinity.
     * If a TimeRange is provided, either start or end must be provided - both fields cannot be empty.
     *
     */
    end?: string;
};

/**
 * An alert, indicating some sort of incident in the public transit network.
 */
export type Alert = {
    /**
     * Time when the alert should be shown to the user.
     * If missing, the alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     *
     */
    communicationPeriod?: Array<TimeRange>;
    /**
     * Time when the services are affected by the disruption mentioned in the alert.
     */
    impactPeriod?: Array<TimeRange>;
    cause?: AlertCause;
    /**
     * Description of the cause of the alert that allows for agency-specific language;
     * more specific than the Cause.
     *
     */
    causeDetail?: string;
    effect?: AlertEffect;
    /**
     * Description of the effect of the alert that allows for agency-specific language;
     * more specific than the Effect.
     *
     */
    effectDetail?: string;
    /**
     * The URL which provides additional information about the alert.
     */
    url?: string;
    /**
     * Header for the alert. This plain-text string will be highlighted, for example in boldface.
     *
     */
    headerText: string;
    /**
     * Description for the alert.
     * This plain-text string will be formatted as the body of the alert (or shown on an explicit "expand" request by the user).
     * The information in the description should add to the information of the header.
     *
     */
    descriptionText: string;
    /**
     * Text containing the alert's header to be used for text-to-speech implementations.
     * This field is the text-to-speech version of header_text.
     * It should contain the same information as headerText but formatted such that it can read as text-to-speech
     * (for example, abbreviations removed, numbers spelled out, etc.)
     *
     */
    ttsHeaderText?: string;
    /**
     * Text containing a description for the alert to be used for text-to-speech implementations.
     * This field is the text-to-speech version of description_text.
     * It should contain the same information as description_text but formatted such that it can be read as text-to-speech
     * (for example, abbreviations removed, numbers spelled out, etc.)
     *
     */
    ttsDescriptionText?: string;
    /**
     * Severity of the alert.
     */
    severityLevel?: AlertSeverityLevel;
    /**
     * String containing an URL linking to an image.
     */
    imageUrl?: string;
    /**
     * IANA media type as to specify the type of image to be displayed. The type must start with "image/"
     *
     */
    imageMediaType?: string;
    /**
     * Text describing the appearance of the linked image in the image field
     * (e.g., in case the image can't be displayed or the user can't see the image for accessibility reasons).
     * See the HTML spec for alt image text.
     *
     */
    imageAlternativeText?: string;
};

/**
 * Object containing duration if a path was found or none if no path was found
 */
export type Duration = {
    /**
     * duration in seconds if a path was found, otherwise missing
     */
    duration?: number;
};

/**
 * Administrative area
 */
export type Area = {
    /**
     * Name of the area
     */
    name: string;
    /**
     * [OpenStreetMap `admin_level`](https://wiki.openstreetmap.org/wiki/Key:admin_level)
     * of the area
     *
     */
    adminLevel: number;
    /**
     * Whether this area was matched by the input text
     */
    matched: boolean;
    /**
     * Set for the first area after the `default` area that distinguishes areas
     * if the match is ambiguous regarding (`default` area + place name / street [+ house number]).
     *
     */
    unique?: boolean;
    /**
     * Whether this area should be displayed as default area (area with admin level closest 7)
     */
    default?: boolean;
};

/**
 * Matched token range (from index, length)
 */
export type Token = [
    number,
    number
];

/**
 * location type
 */
export type LocationType = 'ADDRESS' | 'PLACE' | 'STOP';

/**
 * GeoCoding match
 */
export type Match = {
    type: LocationType;
    /**
     * list of non-overlapping tokens that were matched
     */
    tokens: Array<Token>;
    /**
     * name of the location (transit stop / PoI / address)
     */
    name: string;
    /**
     * unique ID of the location
     */
    id: string;
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    /**
     * level according to OpenStreetMap
     * (at the moment only for public transport)
     *
     */
    level?: number;
    /**
     * street name
     */
    street?: string;
    /**
     * house number
     */
    houseNumber?: string;
    /**
     * zip code
     */
    zip?: string;
    /**
     * list of areas
     */
    areas: Array<Area>;
    /**
     * score according to the internal scoring system (the scoring algorithm might change in the future)
     */
    score: number;
};

/**
 * Different elevation cost profiles for street routing.
 * Using a elevation cost profile will prefer routes with a smaller incline and smaller difference in elevation, even if the routed way is longer.
 *
 * - `NONE`: Ignore elevation data for routing. This is the default behavior
 * - `LOW`: Add a low penalty for inclines. This will favor longer paths, if the elevation increase and incline are smaller.
 * - `HIGH`: Add a high penalty for inclines. This will favor even longer paths, if the elevation increase and incline are smaller.
 *
 */
export type ElevationCosts = 'NONE' | 'LOW' | 'HIGH';

/**
 * Different accessibility profiles for pedestrians.
 */
export type PedestrianProfile = 'FOOT' | 'WHEELCHAIR';

/**
 * # Street modes
 *
 * - `WALK`
 * - `BIKE`
 * - `RENTAL` Experimental. Expect unannounced breaking changes (without version bumps) for all parameters and returned structs.
 * - `CAR`
 * - `CAR_PARKING` Experimental. Expect unannounced breaking changes (without version bumps) for all parameters and returned structs.
 * - `CAR_DROPOFF` Experimental. Expect unannounced breaking changes (without version bumps) for all perameters and returned structs.
 * - `ODM` on-demand taxis from the Prima+Ã–V Project
 * - `FLEX` flexible transports
 *
 * # Transit modes
 *
 * - `TRANSIT`: translates to `RAIL,TRAM,BUS,FERRY,AIRPLANE,COACH,CABLE_CAR,FUNICULAR,AREAL_LIFT,OTHER`
 * - `TRAM`: trams
 * - `SUBWAY`: subway trains
 * - `FERRY`: ferries
 * - `AIRPLANE`: airline flights
 * - `BUS`: short distance buses (does not include `COACH`)
 * - `COACH`: long distance buses (does not include `BUS`)
 * - `RAIL`: translates to `HIGHSPEED_RAIL,LONG_DISTANCE,NIGHT_RAIL,REGIONAL_RAIL,REGIONAL_FAST_RAIL,METRO,SUBWAY`
 * - `METRO`: metro trains
 * - `HIGHSPEED_RAIL`: long distance high speed trains (e.g. TGV)
 * - `LONG_DISTANCE`: long distance inter city trains
 * - `NIGHT_RAIL`: long distance night trains
 * - `REGIONAL_FAST_RAIL`: regional express routes that skip low traffic stops to be faster
 * - `REGIONAL_RAIL`: regional train
 * - `CABLE_CAR`: Cable tram. Used for street-level rail cars where the cable runs beneath the vehicle (e.g., cable car in San Francisco).
 * - `FUNICULAR`: Funicular. Any rail system designed for steep inclines.
 * - `AREAL_LIFT`: Aerial lift, suspended cable car (e.g., gondola lift, aerial tramway). Cable transport where cabins, cars, gondolas or open chairs are suspended by means of one or more cables.
 *
 */
export type Mode = 'WALK' | 'BIKE' | 'RENTAL' | 'CAR' | 'CAR_PARKING' | 'CAR_DROPOFF' | 'ODM' | 'FLEX' | 'TRANSIT' | 'TRAM' | 'SUBWAY' | 'FERRY' | 'AIRPLANE' | 'METRO' | 'BUS' | 'COACH' | 'RAIL' | 'HIGHSPEED_RAIL' | 'LONG_DISTANCE' | 'NIGHT_RAIL' | 'REGIONAL_FAST_RAIL' | 'REGIONAL_RAIL' | 'CABLE_CAR' | 'FUNICULAR' | 'AREAL_LIFT' | 'OTHER';

/**
 * - `NORMAL` - latitude / longitude coordinate or address
 * - `BIKESHARE` - bike sharing station
 * - `TRANSIT` - transit stop
 *
 */
export type VertexType = 'NORMAL' | 'BIKESHARE' | 'TRANSIT';

/**
 * - `NORMAL` - entry/exit is possible normally
 * - `NOT_ALLOWED` - entry/exit is not allowed
 *
 */
export type PickupDropoffType = 'NORMAL' | 'NOT_ALLOWED';

export type Place = {
    /**
     * name of the transit stop / PoI / address
     */
    name: string;
    /**
     * The ID of the stop. This is often something that users don't care about.
     */
    stopId?: string;
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    /**
     * level according to OpenStreetMap
     */
    level: number;
    /**
     * arrival time
     */
    arrival?: string;
    /**
     * departure time
     */
    departure?: string;
    /**
     * scheduled arrival time
     */
    scheduledArrival?: string;
    /**
     * scheduled departure time
     */
    scheduledDeparture?: string;
    /**
     * scheduled track from the static schedule timetable dataset
     */
    scheduledTrack?: string;
    /**
     * The current track/platform information, updated with real-time updates if available.
     * Can be missing if neither real-time updates nor the schedule timetable contains track information.
     *
     */
    track?: string;
    /**
     * description of the location that provides more detailed information
     */
    description?: string;
    vertexType?: VertexType;
    /**
     * Type of pickup. It could be disallowed due to schedule, skipped stops or cancellations.
     */
    pickupType?: PickupDropoffType;
    /**
     * Type of dropoff. It could be disallowed due to schedule, skipped stops or cancellations.
     */
    dropoffType?: PickupDropoffType;
    /**
     * Whether this stop is cancelled due to the realtime situation.
     */
    cancelled?: boolean;
    /**
     * Alerts for this stop.
     */
    alerts?: Array<Alert>;
    /**
     * for `FLEX` transports, the flex location area or location group name
     */
    flex?: string;
    /**
     * for `FLEX` transports, the flex location area ID or location group ID
     */
    flexId?: string;
    /**
     * Time that on-demand service becomes available
     */
    flexStartPickupDropOffWindow?: string;
    /**
     * Time that on-demand service ends
     */
    flexEndPickupDropOffWindow?: string;
};

/**
 * Place reachable by One-to-All
 */
export type ReachablePlace = {
    /**
     * Place reached by One-to-All
     */
    place?: Place;
    /**
     * Total travel duration
     */
    duration?: number;
    /**
     * k is the smallest number, for which a journey with the shortest duration and at most k-1 transfers exist.
     * You can think of k as the number of connections used.
     *
     * In more detail:
     *
     * k=0: No connection, e.g. for the one location
     * k=1: Direct connection
     * k=2: Connection with 1 transfer
     *
     */
    k?: number;
};

/**
 * Object containing all reachable places by One-to-All search
 */
export type Reachable = {
    /**
     * One location used in One-to-All search
     */
    one?: Place;
    /**
     * List of locations reachable by One-to-All
     */
    all?: Array<ReachablePlace>;
};

/**
 * departure or arrival event at a stop
 */
export type StopTime = {
    /**
     * information about the stop place and time
     */
    place: Place;
    /**
     * Transport mode for this leg
     */
    mode: Mode;
    /**
     * Whether there is real-time data about this leg
     */
    realTime: boolean;
    /**
     * For transit legs, the headsign of the bus or train being used.
     * For non-transit legs, null
     *
     */
    headsign: string;
    agencyId: string;
    agencyName: string;
    agencyUrl: string;
    routeColor?: string;
    routeTextColor?: string;
    tripId: string;
    routeShortName: string;
    /**
     * Type of pickup (for departures) or dropoff (for arrivals), may be disallowed either due to schedule, skipped stops or cancellations
     */
    pickupDropoffType: PickupDropoffType;
    /**
     * Whether the departure/arrival is cancelled due to the realtime situation (either because the stop is skipped or because the entire trip is cancelled).
     */
    cancelled: boolean;
    /**
     * Whether the entire trip is cancelled due to the realtime situation.
     */
    tripCancelled: boolean;
    /**
     * Filename and line number where this trip is from
     */
    source: string;
};

/**
 * trip id and name
 */
export type TripInfo = {
    /**
     * trip ID (dataset trip id prefixed with the dataset tag)
     */
    tripId: string;
    /**
     * trip display name
     */
    routeShortName: string;
};

/**
 * trip segment between two stops to show a trip on a map
 */
export type TripSegment = {
    trips: Array<TripInfo>;
    routeColor?: string;
    /**
     * Transport mode for this leg
     */
    mode: Mode;
    /**
     * distance in meters
     */
    distance: number;
    from: Place;
    to: Place;
    /**
     * departure time
     */
    departure: string;
    /**
     * arrival time
     */
    arrival: string;
    /**
     * scheduled departure time
     */
    scheduledDeparture: string;
    /**
     * scheduled arrival time
     */
    scheduledArrival: string;
    /**
     * Whether there is real-time data about this leg
     */
    realTime: boolean;
    /**
     * Google polyline encoded coordinate sequence (with precision 5) where the trip travels on this segment.
     */
    polyline: string;
};

export type Direction = 'DEPART' | 'HARD_LEFT' | 'LEFT' | 'SLIGHTLY_LEFT' | 'CONTINUE' | 'SLIGHTLY_RIGHT' | 'RIGHT' | 'HARD_RIGHT' | 'CIRCLE_CLOCKWISE' | 'CIRCLE_COUNTERCLOCKWISE' | 'STAIRS' | 'ELEVATOR' | 'UTURN_LEFT' | 'UTURN_RIGHT';

export type EncodedPolyline = {
    /**
     * The encoded points of the polyline using the Google polyline encoding.
     */
    points: string;
    /**
     * The precision of the returned polyline (7 for /v1, 6 for /v2)
     * Be aware that with precision 7, coordinates with |longitude| > 107.37 are undefined/will overflow.
     *
     */
    precision: number;
    /**
     * The number of points in the string
     */
    length: number;
};

export type StepInstruction = {
    relativeDirection: Direction;
    /**
     * The distance in meters that this step takes.
     */
    distance: number;
    /**
     * level where this segment starts, based on OpenStreetMap data
     */
    fromLevel: number;
    /**
     * level where this segment starts, based on OpenStreetMap data
     */
    toLevel: number;
    /**
     * OpenStreetMap way index
     */
    osmWay?: number;
    polyline: EncodedPolyline;
    /**
     * The name of the street.
     */
    streetName: string;
    /**
     * Not implemented!
     * When exiting a highway or traffic circle, the exit name/number.
     *
     */
    exit: string;
    /**
     * Not implemented!
     * Indicates whether or not a street changes direction at an intersection.
     *
     */
    stayOn: boolean;
    /**
     * Not implemented!
     * This step is on an open area, such as a plaza or train platform,
     * and thus the directions should say something like "cross"
     *
     */
    area: boolean;
    /**
     * Indicates that a fee must be paid by general traffic to use a road, road bridge or road tunnel.
     */
    toll?: boolean;
    /**
     * Experimental. Indicates whether access to this part of the route is restricted.
     * See: https://wiki.openstreetmap.org/wiki/Conditional_restrictions
     *
     */
    accessRestriction?: string;
    /**
     * incline in meters across this path segment
     */
    elevationUp?: number;
    /**
     * decline in meters across this path segment
     */
    elevationDown?: number;
};

export type RentalFormFactor = 'BICYCLE' | 'CARGO_BICYCLE' | 'CAR' | 'MOPED' | 'SCOOTER_STANDING' | 'SCOOTER_SEATED' | 'OTHER';

export type RentalPropulsionType = 'HUMAN' | 'ELECTRIC_ASSIST' | 'ELECTRIC' | 'COMBUSTION' | 'COMBUSTION_DIESEL' | 'HYBRID' | 'PLUG_IN_HYBRID' | 'HYDROGEN_FUEL_CELL';

export type RentalReturnConstraint = 'NONE' | 'ANY_STATION' | 'ROUNDTRIP_STATION';

/**
 * Vehicle rental
 */
export type Rental = {
    /**
     * Vehicle share system ID
     */
    systemId: string;
    /**
     * Vehicle share system name
     */
    systemName?: string;
    /**
     * URL of the vehicle share system
     */
    url?: string;
    /**
     * Name of the station
     */
    stationName?: string;
    /**
     * Name of the station where the vehicle is picked up (empty for free floating vehicles)
     */
    fromStationName?: string;
    /**
     * Name of the station where the vehicle is returned (empty for free floating vehicles)
     */
    toStationName?: string;
    /**
     * Rental URI for Android (deep link to the specific station or vehicle)
     */
    rentalUriAndroid?: string;
    /**
     * Rental URI for iOS (deep link to the specific station or vehicle)
     */
    rentalUriIOS?: string;
    /**
     * Rental URI for web (deep link to the specific station or vehicle)
     */
    rentalUriWeb?: string;
    formFactor?: RentalFormFactor;
    propulsionType?: RentalPropulsionType;
    returnConstraint?: RentalReturnConstraint;
};

export type Leg = {
    /**
     * Transport mode for this leg
     */
    mode: Mode;
    from: Place;
    to: Place;
    /**
     * Leg duration in seconds
     *
     * If leg is footpath:
     * The footpath duration is derived from the default footpath
     * duration using the query parameters `transferTimeFactor` and
     * `additionalTransferTime` as follows:
     * `leg.duration = defaultDuration * transferTimeFactor + additionalTransferTime.`
     * In case the defaultDuration is needed, it can be calculated by
     * `defaultDuration = (leg.duration - additionalTransferTime) / transferTimeFactor`.
     * Note that the default values are `transferTimeFactor = 1` and
     * `additionalTransferTime = 0` in case they are not explicitly
     * provided in the query.
     *
     */
    duration: number;
    /**
     * leg departure time
     */
    startTime: string;
    /**
     * leg arrival time
     */
    endTime: string;
    /**
     * scheduled leg departure time
     */
    scheduledStartTime: string;
    /**
     * scheduled leg arrival time
     */
    scheduledEndTime: string;
    /**
     * Whether there is real-time data about this leg
     */
    realTime: boolean;
    /**
     * Whether this leg was originally scheduled to run or is an additional service.
     * Scheduled times will equal realtime times in this case.
     *
     */
    scheduled: boolean;
    /**
     * For non-transit legs the distance traveled while traversing this leg in meters.
     */
    distance?: number;
    /**
     * For transit legs, if the rider should stay on the vehicle as it changes route names.
     */
    interlineWithPreviousLeg?: boolean;
    /**
     * For transit legs, the headsign of the bus or train being used.
     * For non-transit legs, null
     *
     */
    headsign?: string;
    routeColor?: string;
    routeTextColor?: string;
    routeType?: string;
    agencyName?: string;
    agencyUrl?: string;
    agencyId?: string;
    tripId?: string;
    routeShortName?: string;
    /**
     * Whether this trip is cancelled
     */
    cancelled?: boolean;
    /**
     * Filename and line number where this trip is from
     */
    source?: string;
    /**
     * For transit legs, intermediate stops between the Place where the leg originates
     * and the Place where the leg ends. For non-transit legs, null.
     *
     */
    intermediateStops?: Array<Place>;
    legGeometry: EncodedPolyline;
    /**
     * A series of turn by turn instructions
     * used for walking, biking and driving.
     *
     */
    steps?: Array<StepInstruction>;
    rental?: Rental;
    /**
     * Index into `Itinerary.fareTransfers` array
     * to identify which fare transfer this leg belongs to
     *
     */
    fareTransferIndex?: number;
    /**
     * Index into the `Itinerary.fareTransfers[fareTransferIndex].effectiveFareLegProducts` array
     * to identify which effective fare leg this itinerary leg belongs to
     *
     */
    effectiveFareLegIndex?: number;
    /**
     * Alerts for this stop.
     */
    alerts?: Array<Alert>;
    /**
     * If set, this attribute indicates that this trip has been expanded
     * beyond the feed end date (enabled by config flag `timetable.dataset.extend_calendar`)
     * by looping active weekdays, e.g. from calendar.txt in GTFS.
     *
     */
    loopedCalendarSince?: string;
};

export type RiderCategory = {
    /**
     * Rider category name as displayed to the rider.
     */
    riderCategoryName: string;
    /**
     * Specifies if this category should be considered the default (i.e. the main category displayed to riders).
     */
    isDefaultFareCategory: boolean;
    /**
     * URL to a web page providing detailed information about the rider category and/or its eligibility criteria.
     */
    eligibilityUrl?: string;
};

/**
 * - `NONE`: No fare media involved (e.g., cash payment)
 * - `PAPER_TICKET`: Physical paper ticket
 * - `TRANSIT_CARD`: Physical transit card with stored value
 * - `CONTACTLESS_EMV`: cEMV (contactless payment)
 * - `MOBILE_APP`: Mobile app with virtual transit cards/passes
 *
 */
export type FareMediaType = 'NONE' | 'PAPER_TICKET' | 'TRANSIT_CARD' | 'CONTACTLESS_EMV' | 'MOBILE_APP';

export type FareMedia = {
    /**
     * Name of the fare media. Required for transit cards and mobile apps.
     */
    fareMediaName?: string;
    /**
     * The type of fare media.
     */
    fareMediaType: FareMediaType;
};

export type FareProduct = {
    /**
     * The name of the fare product as displayed to riders.
     */
    name: string;
    /**
     * The cost of the fare product. May be negative to represent transfer discounts. May be zero to represent a fare product that is free.
     */
    amount: number;
    /**
     * ISO 4217 currency code. The currency of the cost of the fare product.
     */
    currency: string;
    riderCategory?: RiderCategory;
    media?: FareMedia;
};

export type FareTransferRule = 'A_AB' | 'A_AB_B' | 'AB';

/**
 * The concept is derived from: https://gtfs.org/documentation/schedule/reference/#fare_transfer_rulestxt
 *
 * Terminology:
 * - **Leg**: An itinerary leg as described by the `Leg` type of this API description.
 * - **Effective Fare Leg**: Itinerary legs can be joined together to form one *effective fare leg*.
 * - **Fare Transfer**: A fare transfer groups two or more effective fare legs.
 * - **A** is the first *effective fare leg* of potentially multiple consecutive legs contained in a fare transfer
 * - **B** is any *effective fare leg* following the first *effective fare leg* in this transfer
 * - **AB** are all changes between *effective fare legs* contained in this transfer
 *
 * The fare transfer rule is used to derive the final set of products of the itinerary legs contained in this transfer:
 * - A_AB means that any product from the first effective fare leg combined with the product attached to the transfer itself (AB) which can be empty (= free). Note that all subsequent effective fare leg products need to be ignored in this case.
 * - A_AB_B mean that a product for each effective fare leg needs to be purchased in a addition to the product attached to the transfer itself (AB) which can be empty (= free)
 * - AB only the transfer product itself has to be purchased. Note that all fare products attached to the contained effective fare legs need to be ignored in this case.
 *
 * An itinerary `Leg` references the index of the fare transfer and the index of the effective fare leg in this transfer it belongs to.
 *
 */
export type FareTransfer = {
    rule?: FareTransferRule;
    transferProducts?: Array<FareProduct>;
    /**
     * Lists all valid fare products for the effective fare legs.
     * This is an `array<array<FareProduct>>` where the inner array
     * lists all possible fare products that would cover this effective fare leg.
     * Each "effective fare leg" can have multiple options for adult/child/weekly/monthly/day/one-way tickets etc.
     * You can see the outer array as AND (you need one ticket for each effective fare leg (`A_AB_B`), the first effective fare leg (`A_AB`) or no fare leg at all but only the transfer product (`AB`)
     * and the inner array as OR (you can choose which ticket to buy)
     *
     */
    effectiveFareLegProducts: Array<Array<Array<FareProduct>>>;
};

export type Itinerary = {
    /**
     * journey duration in seconds
     */
    duration: number;
    /**
     * journey departure time
     */
    startTime: string;
    /**
     * journey arrival time
     */
    endTime: string;
    /**
     * The number of transfers this trip has.
     */
    transfers: number;
    /**
     * Journey legs
     */
    legs: Array<Leg>;
    /**
     * Fare information
     */
    fareTransfers?: Array<FareTransfer>;
};

/**
 * transfer from one location to another
 */
export type Transfer = {
    to: Place;
    /**
     * optional; missing if the GTFS did not contain a transfer
     * transfer duration in minutes according to GTFS (+heuristics)
     *
     */
    default?: number;
    /**
     * optional; missing if no path was found (timetable / osr)
     * transfer duration in minutes for the foot profile
     *
     */
    foot?: number;
    /**
     * optional; missing if no path was found with foot routing
     * transfer duration in minutes for the foot profile
     *
     */
    footRouted?: number;
    /**
     * optional; missing if no path was found with the wheelchair profile
     * transfer duration in minutes for the wheelchair profile
     *
     */
    wheelchair?: number;
    /**
     * optional; missing if no path was found with the wheelchair profile
     * transfer duration in minutes for the wheelchair profile
     *
     */
    wheelchairRouted?: number;
    /**
     * optional; missing if no path was found with the wheelchair profile
     * true if the wheelchair path uses an elevator
     *
     */
    wheelchairUsesElevator?: boolean;
    /**
     * optional; missing if no path was found with car routing
     * transfer duration in minutes for the car profile
     *
     */
    car?: number;
};

export type PlanData = {
    query: {
        /**
         * Optional. Default is 0 minutes.
         *
         * Additional transfer time reserved for each transfer in minutes.
         *
         */
        additionalTransferTime?: number;
        /**
         * Optional. Default is `false`.
         *
         * - `arriveBy=true`: the parameters `date` and `time` refer to the arrival time
         * - `arriveBy=false`: the parameters `date` and `time` refer to the departure time
         *
         */
        arriveBy?: boolean;
        /**
         * - true: Compute transfer polylines and step instructions.
         * - false: Only return basic information (start time, end time, duration) for transfers.
         *
         */
        detailedTransfers: boolean;
        /**
         * Optional. Default is `WALK` which will compute walking routes as direct connections.
         *
         * Modes used for direction connections from start to destination without using transit.
         * Results will be returned on the `direct` key.
         *
         * Note: Direct connections will only be returned on the first call. For paging calls, they can be omitted.
         *
         * Note: Transit connections that are slower than the fastest direct connection will not show up.
         * This is being used as a cut-off during transit routing to speed up the search.
         * To prevent this, it's possible to send two separate requests (one with only `transitModes` and one with only `directModes`).
         *
         * Note: the output `direct` array will stay empty if the input param `maxDirectTime` makes any direct trip impossible.
         *
         * Only non-transit modes such as `WALK`, `BIKE`, `CAR`, `BIKE_SHARING`, etc. can be used.
         *
         */
        directModes?: Array<Mode>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies to direct connections.
         *
         * A list of vehicle type form factors that are allowed to be used for direct connections.
         * If empty (the default), all form factors are allowed.
         * Example: `BICYCLE,SCOOTER_STANDING`.
         *
         */
        directRentalFormFactors?: Array<RentalFormFactor>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies to direct connections.
         *
         * A list of vehicle type form factors that are allowed to be used for direct connections.
         * If empty (the default), all propulsion types are allowed.
         * Example: `HUMAN,ELECTRIC,ELECTRIC_ASSIST`.
         *
         */
        directRentalPropulsionTypes?: Array<RentalPropulsionType>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies to direct connections.
         *
         * A list of rental providers that are allowed to be used for direct connections.
         * If empty (the default), all providers are allowed.
         *
         */
        directRentalProviders?: Array<(string)>;
        /**
         * Optional. Default is `NONE`.
         *
         * Set an elevation cost profile, to penalize routes with incline.
         * - `NONE`: No additional costs for elevations. This is the default behavior
         * - `LOW`: Add a low cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if small detours are required.
         * - `HIGH`: Add a high cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if larger detours are required.
         *
         * As using an elevation costs profile will increase the travel duration,
         * routing through steep terrain may exceed the maximal allowed duration,
         * causing a location to appear unreachable.
         * Increasing the maximum travel time for these segments may resolve this issue.
         *
         * The profile is used for direct routing, on the first mile, and last mile.
         *
         * Elevation cost profiles are currently used by following street modes:
         * - `BIKE`
         *
         */
        elevationCosts?: ElevationCosts;
        /**
         * Optional. Experimental. Default is `1.0`.
         * Factor with which the duration of the fastest direct non-public-transit connection is multiplied.
         * Values > 1.0 allow transit connections that are slower than the fastest direct non-public-transit connection to be found.
         *
         */
        fastestDirectFactor?: number;
        /**
         * Optional.
         * Factor with which the duration of the fastest slowDirect connection is multiplied.
         * Values > 1.0 allow connections that are slower than the fastest direct connection to be found.
         * Values < 1.0 will return all slowDirect connections.
         *
         */
        fastestSlowDirectFactor?: number;
        /**
         * \`latitude,longitude[,level]\` tuple with
         * - latitude and longitude in degrees
         * - (optional) level: the OSM level (default: 0)
         *
         * OR
         *
         * stop id
         *
         */
        fromPlace: string;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Default is `false`.
         *
         * If set to `true`, the routing will ignore rental return constraints for direct connections,
         * allowing the rental vehicle to be parked anywhere.
         *
         */
        ignoreDirectRentalReturnConstraints?: boolean;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Default is `false`.
         *
         * If set to `true`, the routing will ignore rental return constraints for the part from the last transit stop to the `to` coordinate,
         * allowing the rental vehicle to be parked anywhere.
         *
         */
        ignorePostTransitRentalReturnConstraints?: boolean;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Default is `false`.
         *
         * If set to `true`, the routing will ignore rental return constraints for the part from the `from` coordinate to the first transit stop,
         * allowing the rental vehicle to be parked anywhere.
         *
         */
        ignorePreTransitRentalReturnConstraints?: boolean;
        /**
         * Optional. Default is `true`.
         *
         * Controls if a journey section with stay-seated transfers is returned:
         * - `joinInterlinedLegs=false`: as several legs (full information about all trip numbers, headsigns, etc.).
         * Legs that do not require a transfer (stay-seated transfer) are marked with `interlineWithPreviousLeg=true`.
         * - `joinInterlinedLegs=true` (default behavior): as only one joined leg containing all stops
         *
         */
        joinInterlinedLegs?: boolean;
        /**
         * language tags as used in OpenStreetMap / GTFS
         * (usually BCP-47 / ISO 639-1, or ISO 639-2 if there's no ISO 639-1)
         *
         */
        language?: string;
        /**
         * Optional. Experimental. Number of luggage pieces; base unit: airline cabin luggage (e.g. for ODM or price calculation)
         *
         */
        luggage?: number;
        /**
         * Optional. Default is 30min which is `1800`.
         * Maximum time in seconds for direct connections.
         *
         */
        maxDirectTime?: number;
        /**
         * Optional. Default is 25 meters.
         *
         * Maximum matching distance in meters to match geo coordinates to the street network.
         *
         */
        maxMatchingDistance?: number;
        /**
         * Optional. Default is 15min which is `900`.
         * Maximum time in seconds for the last street leg.
         *
         */
        maxPostTransitTime?: number;
        /**
         * Optional. Default is 15min which is `900`.
         * Maximum time in seconds for the first street leg.
         *
         */
        maxPreTransitTime?: number;
        /**
         * The maximum number of allowed transfers (i.e. interchanges between transit legs,
         * pre- and postTransit do not count as transfers).
         * `maxTransfers=0` searches for direct transit connections without any transfers.
         * If you want to search only for non-transit connections (`FOOT`, `CAR`, etc.),
         * send an empty `transitModes` parameter instead.
         *
         * If not provided, the routing uses the server-side default value
         * which is hardcoded and very high to cover all use cases.
         *
         * *Warning*: Use with care. Setting this too low can lead to
         * optimal (e.g. the fastest) journeys not being found.
         * If this value is too low to reach the destination at all,
         * it can lead to slow routing performance.
         *
         * In plan endpoints before v3, the behavior is off by one,
         * i.e. `maxTransfers=0` only returns non-transit connections.
         *
         */
        maxTransfers?: number;
        /**
         * The maximum travel time in minutes.
         * If not provided, the routing to uses the value
         * hardcoded in the server which is usually quite high.
         *
         * *Warning*: Use with care. Setting this too low can lead to
         * optimal (e.g. the least transfers) journeys not being found.
         * If this value is too low to reach the destination at all,
         * it can lead to slow routing performance.
         *
         */
        maxTravelTime?: number;
        /**
         * Optional. Default is 0 minutes.
         *
         * Minimum transfer time for each transfer in minutes.
         *
         */
        minTransferTime?: number;
        /**
         * The minimum number of itineraries to compute.
         * This is only relevant if `timetableView=true`.
         * The default value is 5.
         *
         */
        numItineraries?: number;
        /**
         * Use the cursor to go to the next "page" of itineraries.
         * Copy the cursor from the last response and keep the original request as is.
         * This will enable you to search for itineraries in the next or previous time-window.
         *
         */
        pageCursor?: string;
        /**
         * Optional. Experimental. Number of passengers (e.g. for ODM or price calculation)
         */
        passengers?: number;
        /**
         * Optional. Default is `FOOT`.
         *
         * Accessibility profile to use for pedestrian routing in transfers
         * between transit connections, on the first mile, and last mile.
         *
         */
        pedestrianProfile?: PedestrianProfile;
        /**
         * Optional. Default is `WALK`. Only applies if the `to` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directModes`).
         *
         * A list of modes that are allowed to be used from the last transit stop to the `to` coordinate. Example: `WALK,BIKE_SHARING`.
         *
         */
        postTransitModes?: Array<Mode>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `to` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalFormFactors`).
         *
         * A list of vehicle type form factors that are allowed to be used from the last transit stop to the `to` coordinate.
         * If empty (the default), all form factors are allowed.
         * Example: `BICYCLE,SCOOTER_STANDING`.
         *
         */
        postTransitRentalFormFactors?: Array<RentalFormFactor>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `to` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalPropulsionTypes`).
         *
         * A list of vehicle propulsion types that are allowed to be used from the last transit stop to the `to` coordinate.
         * If empty (the default), all propulsion types are allowed.
         * Example: `HUMAN,ELECTRIC,ELECTRIC_ASSIST`.
         *
         */
        postTransitRentalPropulsionTypes?: Array<RentalPropulsionType>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `to` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalProviders`).
         *
         * A list of rental providers that are allowed to be used from the last transit stop to the `to` coordinate.
         * If empty (the default), all providers are allowed.
         *
         */
        postTransitRentalProviders?: Array<(string)>;
        /**
         * Optional. Default is `WALK`. Only applies if the `from` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directModes`).
         *
         * A list of modes that are allowed to be used from the `from` coordinate to the first transit stop. Example: `WALK,BIKE_SHARING`.
         *
         */
        preTransitModes?: Array<Mode>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `from` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalFormFactors`).
         *
         * A list of vehicle type form factors that are allowed to be used from the `from` coordinate to the first transit stop.
         * If empty (the default), all form factors are allowed.
         * Example: `BICYCLE,SCOOTER_STANDING`.
         *
         */
        preTransitRentalFormFactors?: Array<RentalFormFactor>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `from` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalPropulsionTypes`).
         *
         * A list of vehicle propulsion types that are allowed to be used from the `from` coordinate to the first transit stop.
         * If empty (the default), all propulsion types are allowed.
         * Example: `HUMAN,ELECTRIC,ELECTRIC_ASSIST`.
         *
         */
        preTransitRentalPropulsionTypes?: Array<RentalPropulsionType>;
        /**
         * Experimental. Expect unannounced breaking changes (without version bumps).
         *
         * Optional. Only applies if the `from` place is a coordinate (not a transit stop). Does not apply to direct connections (see `directRentalProviders`).
         *
         * A list of rental providers that are allowed to be used from the `from` coordinate to the first transit stop.
         * If empty (the default), all providers are allowed.
         *
         */
        preTransitRentalProviders?: Array<(string)>;
        /**
         * Optional. Default is `false`.
         *
         * If set to `true`, all used transit trips are required to allow bike carriage.
         *
         */
        requireBikeTransport?: boolean;
        /**
         * Optional. Default is `false`.
         *
         * If set to `true`, all used transit trips are required to allow car carriage.
         *
         */
        requireCarTransport?: boolean;
        /**
         * Optional. Default is 2 hours which is `7200`.
         *
         * The length of the search-window in seconds. Default value two hours.
         *
         * - `arriveBy=true`: number of seconds between the earliest departure time and latest departure time
         * - `arriveBy=false`: number of seconds between the earliest arrival time and the latest arrival time
         *
         */
        searchWindow?: number;
        /**
         * Optional. Experimental. Adds overtaken direct public transit connections.
         */
        slowDirect?: boolean;
        /**
         * Optional. Defaults to the current time.
         *
         * Departure time ($arriveBy=false) / arrival date ($arriveBy=true),
         *
         */
        time?: string;
        /**
         * Optional. Query timeout in seconds.
         */
        timeout?: number;
        /**
         * Optional. Default is `true`.
         *
         * Search for the best trip options within a time window.
         * If true two itineraries are considered optimal
         * if one is better on arrival time (earliest wins)
         * and the other is better on departure time (latest wins).
         * In combination with arriveBy this parameter cover the following use cases:
         *
         * `timetable=false` = waiting for the first transit departure/arrival is considered travel time:
         * - `arriveBy=true`: event (e.g. a meeting) starts at 10:00 am,
         * compute the best journeys that arrive by that time (maximizes departure time)
         * - `arriveBy=false`: event (e.g. a meeting) ends at 11:00 am,
         * compute the best journeys that depart after that time
         *
         * `timetable=true` = optimize "later departure" + "earlier arrival" and give all options over a time window:
         * - `arriveBy=true`: the time window around `date` and `time` refers to the arrival time window
         * - `arriveBy=false`: the time window around `date` and `time` refers to the departure time window
         *
         */
        timetableView?: boolean;
        /**
         * \`latitude,longitude[,level]\` tuple with
         * - latitude and longitude in degrees
         * - (optional) level: the OSM level (default: 0)
         *
         * OR
         *
         * stop id
         *
         */
        toPlace: string;
        /**
         * Optional. Default is 1.0
         *
         * Factor to multiply minimum required transfer times with.
         * Values smaller than 1.0 are not supported.
         *
         */
        transferTimeFactor?: number;
        /**
         * Optional. Default is `TRANSIT` which allows all transit modes (no restriction).
         * Allowed modes for the transit part. If empty, no transit connections will be computed.
         * For example, this can be used to allow only `METRO,SUBWAY,TRAM`.
         *
         */
        transitModes?: Array<Mode>;
        /**
         * Optional. Default is `false`.
         *
         * Whether to use transfers routed on OpenStreetMap data.
         *
         */
        useRoutedTransfers?: boolean;
        /**
         * List of via stops to visit (only stop IDs, no coordinates allowed for now).
         * Also see the optional parameter `viaMinimumStay` to set a set a minimum stay duration for each via stop.
         *
         */
        via?: Array<(string)>;
        /**
         * Optional. If not set, the default is `0,0` - no stay required.
         *
         * For each `via` stop a minimum stay duration in minutes.
         *
         * The value `0` signals that it's allowed to stay in the same trip.
         * This enables via stays without counting a transfer and can lead
         * to better connections with less transfers. Transfer connections can
         * still be found with `viaMinimumStay=0`.
         *
         */
        viaMinimumStay?: Array<(number)>;
        /**
         * Optional. Experimental. If set to true, the response will contain fare information.
         */
        withFares?: boolean;
        /**
         * Optional. Include intermediate stops where passengers can not alight/board according to schedule.
         */
        withScheduledSkippedStops?: boolean;
    };
};

export type PlanResponse = ({
    /**
     * the routing query
     */
    requestParameters: {
        [key: string]: (string);
    };
    /**
     * debug statistics
     */
    debugOutput: {
        [key: string]: (number);
    };
    from: Place;
    to: Place;
    /**
     * Direct trips by `WALK`, `BIKE`, `CAR`, etc. without time-dependency.
     * The starting time (`arriveBy=false`) / arrival time (`arriveBy=true`) is always the queried `time` parameter (set to \"now\" if not set).
     * But all `direct` connections are meant to be independent of absolute times.
     *
     */
    direct: Array<Itinerary>;
    /**
     * list of itineraries
     */
    itineraries: Array<Itinerary>;
    /**
     * Use the cursor to get the previous page of results. Insert the cursor into the request and post it to get the previous page.
     * The previous page is a set of itineraries departing BEFORE the first itinerary in the result for a depart after search. When using the default sort order the previous set of itineraries is inserted before the current result.
     *
     */
    previousPageCursor: string;
    /**
     * Use the cursor to get the next page of results. Insert the cursor into the request and post it to get the next page.
     * The next page is a set of itineraries departing AFTER the last itinerary in this result.
     *
     */
    nextPageCursor: string;
});

export type PlanError = unknown;

export type OneToManyData = {
    query: {
        /**
         * true = many to one
         * false = one to many
         *
         */
        arriveBy: boolean;
        /**
         * Optional. Default is `NONE`.
         *
         * Set an elevation cost profile, to penalize routes with incline.
         * - `NONE`: No additional costs for elevations. This is the default behavior
         * - `LOW`: Add a low cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if small detours are required.
         * - `HIGH`: Add a high cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if larger detours are required.
         *
         * As using an elevation costs profile will increase the travel duration,
         * routing through steep terrain may exceed the maximal allowed duration,
         * causing a location to appear unreachable.
         * Increasing the maximum travel time for these segments may resolve this issue.
         *
         * Elevation cost profiles are currently used by following street modes:
         * - `BIKE`
         *
         */
        elevationCosts?: ElevationCosts;
        /**
         * geo locations as latitude;longitude,latitude;longitude,...
         */
        many: Array<(string)>;
        /**
         * maximum travel time in seconds
         */
        max: number;
        /**
         * maximum matching distance in meters to match geo coordinates to the street network
         */
        maxMatchingDistance: number;
        /**
         * routing profile to use (currently supported: \`WALK\`, \`BIKE\`, \`CAR\`)
         *
         */
        mode: Mode;
        /**
         * geo location as latitude;longitude
         */
        one: string;
    };
};

export type OneToManyResponse = (Array<Duration>);

export type OneToManyError = unknown;

export type OneToAllData = {
    query: {
        /**
         * Optional. Default is 0 minutes.
         *
         * Additional transfer time reserved for each transfer in minutes.
         *
         */
        additionalTransferTime?: number;
        /**
         * true = all to one,
         * false = one to all
         *
         */
        arriveBy?: boolean;
        /**
         * Optional. Default is `NONE`.
         *
         * Set an elevation cost profile, to penalize routes with incline.
         * - `NONE`: No additional costs for elevations. This is the default behavior
         * - `LOW`: Add a low cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if small detours are required.
         * - `HIGH`: Add a high cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if larger detours are required.
         *
         * As using an elevation costs profile will increase the travel duration,
         * routing through steep terrain may exceed the maximal allowed duration,
         * causing a location to appear unreachable.
         * Increasing the maximum travel time for these segments may resolve this issue.
         *
         * The profile is used for routing on both the first and last mile.
         *
         * Elevation cost profiles are currently used by following street modes:
         * - `BIKE`
         *
         */
        elevationCosts?: ElevationCosts;
        /**
         * Optional. Default is 25 meters.
         *
         * Maximum matching distance in meters to match geo coordinates to the street network.
         *
         */
        maxMatchingDistance?: number;
        /**
         * Optional. Default is 15min which is `900`.
         * - `arriveBy=true`: Maximum time in seconds for the street leg at `one` location.
         * - `arriveBy=false`: Currently not used
         *
         */
        maxPostTransitTime?: number;
        /**
         * Optional. Default is 15min which is `900`.
         * - `arriveBy=true`: Currently not used
         * - `arriveBy=false`: Maximum time in seconds for the street leg at `one` location.
         *
         */
        maxPreTransitTime?: number;
        /**
         * The maximum number of allowed transfers (i.e. interchanges between transit legs,
         * pre- and postTransit do not count as transfers).
         * `maxTransfers=0` searches for direct transit connections without any transfers.
         * If you want to search only for non-transit connections (`FOOT`, `CAR`, etc.),
         * send an empty `transitModes` parameter instead.
         *
         * If not provided, the routing uses the server-side default value
         * which is hardcoded and very high to cover all use cases.
         *
         * *Warning*: Use with care. Setting this too low can lead to
         * optimal (e.g. the fastest) journeys not being found.
         * If this value is too low to reach the destination at all,
         * it can lead to slow routing performance.
         *
         * In plan endpoints before v3, the behavior is off by one,
         * i.e. `maxTransfers=0` only returns non-transit connections.
         *
         */
        maxTransfers?: number;
        /**
         * maximum travel time in minutes
         */
        maxTravelTime: number;
        /**
         * Optional. Default is 0 minutes.
         *
         * Minimum transfer time for each transfer in minutes.
         *
         */
        minTransferTime?: number;
        /**
         * \`latitude,longitude[,level]\` tuple with
         * - latitude and longitude in degrees
         * - (optional) level: the OSM level (default: 0)
         *
         * OR
         *
         * stop id
         *
         */
        one: string;
        /**
         * Optional. Default is `FOOT`.
         *
         * Accessibility profile to use for pedestrian routing in transfers
         * between transit connections and the first and last mile respectively.
         *
         */
        pedestrianProfile?: PedestrianProfile;
        /**
         * Optional. Default is `WALK`. The behavior depends on whether `arriveBy` is set:
         * - `arriveBy=true`: Only applies if the `one` place is a coordinate (not a transit stop).
         * - `arriveBy=false`: Currently not used
         *
         * A list of modes that are allowed to be used from the last transit stop to the `to` coordinate. Example: `WALK,BIKE_SHARING`.
         *
         */
        postTransitModes?: Array<Mode>;
        /**
         * Optional. Default is `WALK`. The behavior depends on whether `arriveBy` is set:
         * - `arriveBy=true`: Currently not used
         * - `arriveBy=false`: Only applies if the `one` place is a coordinate (not a transit stop).
         *
         * A list of modes that are allowed to be used from the last transit stop to the `to` coordinate. Example: `WALK,BIKE_SHARING`.
         *
         */
        preTransitModes?: Array<Mode>;
        /**
         * Optional. Default is `false`.
         *
         * If set to `true`, all used transit trips are required to allow bike carriage.
         *
         */
        requireBikeTransport?: boolean;
        /**
         * Optional. Default is `false`.
         *
         * If set to `true`, all used transit trips are required to allow car carriage.
         *
         */
        requireCarTransport?: boolean;
        /**
         * Optional. Defaults to the current time.
         *
         * Departure time ($arriveBy=false) / arrival date ($arriveBy=true),
         *
         */
        time?: string;
        /**
         * Optional. Default is 1.0
         *
         * Factor to multiply minimum required transfer times with.
         * Values smaller than 1.0 are not supported.
         *
         */
        transferTimeFactor?: number;
        /**
         * Optional. Default is `TRANSIT` which allows all transit modes (no restriction).
         * Allowed modes for the transit part. If empty, no transit connections will be computed.
         * For example, this can be used to allow only `METRO,SUBWAY,TRAM`.
         *
         */
        transitModes?: Array<Mode>;
        /**
         * Optional. Default is `false`.
         *
         * Whether to use transfers routed on OpenStreetMap data.
         *
         */
        useRoutedTransfers?: boolean;
    };
};

export type OneToAllResponse = (Reachable);

export type OneToAllError = unknown;

export type ReverseGeocodeData = {
    query: {
        /**
         * latitude, longitude in degrees
         */
        place: string;
        /**
         * Optional. Default is all types.
         *
         * Only return results of the given type.
         * For example, this can be used to allow only `ADDRESS` and `STOP` results.
         *
         */
        type?: LocationType;
    };
};

export type ReverseGeocodeResponse = (Array<Match>);

export type ReverseGeocodeError = unknown;

export type GeocodeData = {
    query: {
        /**
         * language tags as used in OpenStreetMap
         * (usually ISO 639-1, or ISO 639-2 if there's no ISO 639-1)
         *
         */
        language?: string;
        /**
         * Optional. Used for biasing results towards the coordinate.
         *
         * Format: latitude,longitude in degrees
         *
         */
        place?: string;
        /**
         * Optional. Used for biasing results towards the coordinate. Higher number = higher bias.
         *
         */
        placeBias?: number;
        /**
         * the (potentially partially typed) address to resolve
         */
        text: string;
        /**
         * Optional. Default is all types.
         *
         * Only return results of the given types.
         * For example, this can be used to allow only `ADDRESS` and `STOP` results.
         *
         */
        type?: LocationType;
    };
};

export type GeocodeResponse = (Array<Match>);

export type GeocodeError = unknown;

export type TripData = {
    query: {
        /**
         * Optional. Default is `true`.
         *
         * Controls if a trip with stay-seated transfers is returned:
         * - `joinInterlinedLegs=false`: as several legs (full information about all trip numbers, headsigns, etc.).
         * Legs that do not require a transfer (stay-seated transfer) are marked with `interlineWithPreviousLeg=true`.
         * - `joinInterlinedLegs=true` (default behavior): as only one joined leg containing all stops
         *
         */
        joinInterlinedLegs?: boolean;
        /**
         * language tags as used in OpenStreetMap / GTFS
         * (usually BCP-47 / ISO 639-1, or ISO 639-2 if there's no ISO 639-1)
         *
         */
        language?: string;
        /**
         * trip identifier (e.g. from an itinerary leg or stop event)
         */
        tripId: string;
        /**
         * Optional. Include intermediate stops where passengers can not alight/board according to schedule.
         */
        withScheduledSkippedStops?: boolean;
    };
};

export type TripResponse = (Itinerary);

export type TripError = unknown;

export type StoptimesData = {
    query: {
        /**
         * Optional. Default is `false`.
         *
         * - `arriveBy=true`: the parameters `date` and `time` refer to the arrival time
         * - `arriveBy=false`: the parameters `date` and `time` refer to the departure time
         *
         */
        arriveBy?: boolean;
        /**
         * This parameter will be ignored in case `pageCursor` is set.
         *
         * Optional. Default is
         * - `LATER` for `arriveBy=false`
         * - `EARLIER` for `arriveBy=true`
         *
         * The response will contain the next `n` arrivals / departures
         * in case `EARLIER` is selected and the previous `n`
         * arrivals / departures if `LATER` is selected.
         *
         */
        direction?: 'EARLIER' | 'LATER';
        /**
         * Optional. Default is `false`.
         *
         * If set to `true`, only stations that are phyiscally in the radius are considered.
         * If set to `false`, additionally to the stations in the radius, equivalences with the same name and children are considered.
         *
         */
        exactRadius?: boolean;
        /**
         * language tags as used in OpenStreetMap / GTFS
         * (usually BCP-47 / ISO 639-1, or ISO 639-2 if there's no ISO 639-1)
         *
         */
        language?: string;
        /**
         * Optional. Default is all transit modes.
         *
         * Only return arrivals/departures of the given modes.
         *
         */
        mode?: Array<Mode>;
        /**
         * the number of events
         */
        n: number;
        /**
         * Use the cursor to go to the next "page" of stop times.
         * Copy the cursor from the last response and keep the original request as is.
         * This will enable you to search for stop times in the next or previous time-window.
         *
         */
        pageCursor?: string;
        /**
         * Optional. Radius in meters.
         *
         * Default is that only stop times of the parent of the stop itself
         * and all stops with the same name (+ their child stops) are returned.
         *
         * If set, all stops at parent stations and their child stops in the specified radius
         * are returned.
         *
         */
        radius?: number;
        /**
         * stop id of the stop to retrieve departures/arrivals for
         */
        stopId: string;
        /**
         * Optional. Defaults to the current time.
         *
         */
        time?: string;
        /**
         * Optional. Include stoptimes where passengers can not alight/board according to schedule.
         */
        withScheduledSkippedStops?: boolean;
    };
};

export type StoptimesResponse = ({
    /**
     * list of stop times
     */
    stopTimes: Array<StopTime>;
    /**
     * metadata of the requested stop
     */
    place: Place;
    /**
     * Use the cursor to get the previous page of results. Insert the cursor into the request and post it to get the previous page.
     * The previous page is a set of stop times BEFORE the first stop time in the result.
     *
     */
    previousPageCursor: string;
    /**
     * Use the cursor to get the next page of results. Insert the cursor into the request and post it to get the next page.
     * The next page is a set of stop times AFTER the last stop time in this result.
     *
     */
    nextPageCursor: string;
});

export type StoptimesError = unknown;

export type TripsData = {
    query: {
        /**
         * end if the time window
         */
        endTime: string;
        /**
         * latitude,longitude pair of the upper left coordinate
         */
        max: string;
        /**
         * latitude,longitude pair of the lower right coordinate
         */
        min: string;
        /**
         * start of the time window
         */
        startTime: string;
        /**
         * current zoom level
         */
        zoom: number;
    };
};

export type TripsResponse = (Array<TripSegment>);

export type TripsError = unknown;

export type InitialResponse = ({
    /**
     * latitude
     */
    lat: number;
    /**
     * longitude
     */
    lon: number;
    /**
     * zoom level
     */
    zoom: number;
});

export type InitialError = unknown;

export type StopsData = {
    query: {
        /**
         * latitude,longitude pair of the upper left coordinate
         */
        max: string;
        /**
         * latitude,longitude pair of the lower right coordinate
         */
        min: string;
    };
};

export type StopsResponse = (Array<Place>);

export type StopsError = unknown;

export type LevelsData = {
    query: {
        /**
         * latitude,longitude pair of the upper left coordinate
         */
        max: string;
        /**
         * latitude,longitude pair of the lower right coordinate
         */
        min: string;
    };
};

export type LevelsResponse = (Array<(number)>);

export type LevelsError = unknown;

export type TransfersData = {
    query: {
        /**
         * location id
         */
        id: string;
    };
};

export type TransfersResponse = ({
    place: Place;
    /**
     * true if the server has foot transfers computed
     */
    hasFootTransfers: boolean;
    /**
     * true if the server has wheelchair transfers computed
     */
    hasWheelchairTransfers: boolean;
    /**
     * true if the server has car transfers computed
     */
    hasCarTransfers: boolean;
    /**
     * all outgoing transfers of this location
     */
    transfers: Array<Transfer>;
});

export type TransfersError = unknown;